<!-- Local HTML template loaded by WebView; replace its contents to customize the app. -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Flag Football Tracker (Touch)</title>
  <style>
    :root {
      --bg: #0f172a; /* slate-900 */
      --card: #ffffff;
      --ink: #0b1120;
      --line: #e2e8f0;
      --accent: #10b981; /* emerald-500 */
      --danger: #ef4444;
      --muted: #64748b;
    }
    html, body { height: 100%; }
    body { margin: 0; overflow-x: hidden; background: var(--bg); color: #e5e7eb; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; transition: background 0.2s ease; }

    body[data-view="player"] {
      background: #020617;
    }

    .topbar {
      position: sticky;
      top: 0;
      z-index: 40;
      background: rgba(15, 23, 42, 0.95);
      border-bottom: 1px solid rgba(148, 163, 184, 0.3);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 16px;
    }

    .menu-toggle {
      border: none;
      background: transparent;
      color: inherit;
      font-size: 22px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      border-radius: 10px;
      cursor: pointer;
    }

    .menu-toggle:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .topbar-title { font-weight: 800; letter-spacing: 0.01em; font-size: 16px; flex: 1; }

    .view-indicator {
      font-size: 13px;
      font-weight: 800;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(148, 163, 184, 0.18);
      color: #e2e8f0;
    }

    .drawer-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.65);
      backdrop-filter: blur(2px);
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s ease;
      z-index: 30;
    }

    .drawer {
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      width: min(360px, 86vw);
      background: #0b1220;
      border-right: 1px solid rgba(148, 163, 184, 0.25);
      transform: translateX(-100%);
      transition: transform 0.2s ease;
      z-index: 40;
      display: flex;
      flex-direction: column;
      padding: 20px 18px 28px;
      gap: 18px;
      overflow-y: auto;
    }

    body.menu-open .drawer { transform: translateX(0); }
    body.menu-open .drawer-backdrop { opacity: 1; visibility: visible; }

    .drawer h2 {
      margin: 0 0 10px;
      font-size: 15px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #cbd5f5;
    }

    .drawer-section { display: flex; flex-direction: column; gap: 10px; }

    .drawer-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      padding: 12px 14px;
      font-weight: 700;
      background: rgba(15, 23, 42, 0.65);
      color: inherit;
      cursor: pointer;
    }

    .drawer-item.active { border-color: var(--accent); background: rgba(16, 185, 129, 0.16); color: #d1fae5; }

    .drawer-note { font-size: 12px; color: #94a3b8; margin: 0; line-height: 1.5; }

    .drawer form { display: flex; flex-direction: column; gap: 10px; }

    .drawer label { font-size: 12px; text-transform: uppercase; letter-spacing: 0.06em; color: #94a3b8; font-weight: 700; }

    .drawer input, .drawer textarea {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(15, 23, 42, 0.6);
      color: #e2e8f0;
      font-size: 14px;
      font-family: inherit;
    }

    .drawer input:focus-visible, .drawer textarea:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }

    .drawer button.save {
      padding: 12px;
      border-radius: 12px;
      border: none;
      font-weight: 800;
      background: var(--accent);
      color: white;
      cursor: pointer;
    }

    .drawer button.secondary {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(15, 23, 42, 0.65);
      color: inherit;
      cursor: pointer;
    }

    .sync-status { font-size: 12px; color: #94a3b8; }

    body.menu-open { overflow: hidden; }

    .app { max-width: 1040px; margin: 0 auto; padding: 16px 12px 32px; display:flex; flex-direction:column; gap:16px; min-height:100vh; }
    h1 { font-size: 20px; margin: 10px 0 6px; font-weight: 800; text-align:center; }

    .layout { display:flex; align-items:flex-start; gap:16px; }
    .primary { flex:1; min-width:0; display:flex; flex-direction:column; gap:12px; }

    /* Clock */
    .clock { display:flex; align-items:center; justify-content:space-between; gap:8px; background:rgba(2,6,23,.7); border:1px solid rgba(148,163,184,.25); border-radius:14px; padding:8px 10px; }
    .clock .left { display:flex; flex-direction:column; gap:4px; }
    .clock .time { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size:26px; font-weight:900; cursor: pointer; }
    .clock-controls { display:flex; gap:6px; flex-wrap: wrap; justify-content:flex-end; }
    .clock-controls .btn { padding:8px 10px; border-radius:12px; border:1px solid rgba(148,163,184,.35); background:#0f172a; color:#e5e7eb; font-weight:800; font-size:14px; }
    .banner { font-size:12px; color:#cbd5e1; font-weight:800; letter-spacing:.02em; }

    /* Teams */
    .teams { display:grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 12px; }

    /* Team card */
    .team { background: var(--card); color: var(--ink); border-radius: 14px; padding: 10px; box-shadow: 0 6px 18px rgba(0,0,0,.18); border: 2px solid var(--line); cursor: pointer; }
    body[data-view="player"] .team { cursor: default; }
    .team.active { border-color: var(--accent); box-shadow: 0 6px 18px rgba(16,185,129,.25); }
    .team header { display:flex; align-items:center; justify-content:center; gap:6px; margin-bottom:10px; }
    .name { font-weight: 900; font-size: 16px; user-select:none; padding:2px 4px; border-radius:6px; }
    body[data-view="player"] .name { cursor: default; }
    .name.editing { background:#f1f5f9; }
    .name-input { font-weight:900; font-size:16px; width:100%; padding:4px 6px; border-radius:8px; border:2px solid var(--line); text-align:center; }

    .stats { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .stat { background:#f8fafc; border:1px solid var(--line); border-radius:10px; padding:10px; display:flex; flex-direction:column; align-items:center; gap:6px; text-align:center; }
    .stat.full { grid-column: 1 / -1; }
    .stat label { display:block; font-size:11px; color:#334155; font-weight:700; text-transform:uppercase; letter-spacing:.04em; }

    /* Inline numeric editor (kept from codex/refactor-inline-editor...) */
    .val { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 22px; font-weight: 900; cursor:pointer; text-align:center; }
    body[data-view="player"] .val { cursor: default; }
    .val.editing { cursor:text; background:#e2e8f0; border-radius:8px; padding:8px; display:flex; flex-direction:column; gap:6px; box-shadow: inset 0 0 0 1px rgba(148,163,184,.4); }
    .val-input { width:100%; padding:12px 10px; border-radius:8px; border:2px solid var(--line); font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size:20px; font-weight:900; text-align:center; color:var(--ink); background:#ffffff; -webkit-appearance: none; }
    .val-input:focus { outline:none; border-color: var(--accent); box-shadow:0 0 0 3px rgba(16,185,129,.2); }
    .val-input.invalid { border-color: var(--danger); box-shadow:0 0 0 3px rgba(239,68,68,.2); }
    .val-error { font-size:11px; color: var(--danger); font-weight:700; min-height:14px; text-align:center; visibility:hidden; }
    .val-error.visible { visibility:visible; }

    /* Global control card */
    .controls-card { position:sticky; top:120px; width: min(280px, 45vw); align-self:stretch; flex-shrink:0; }
    .controls { background:#0b1220; border:1px solid rgba(148,163,184,.35); border-radius:14px; padding:12px; display:flex; flex-direction:column; gap:10px; max-height: calc(100vh - 160px); overflow:auto; }
    .controls .label { font-size:12px; color:#94a3b8; font-weight:800; text-transform:uppercase; letter-spacing:.04em; margin-bottom:6px; }
    .controls .row3 { display:grid; grid-template-columns:repeat(3, 1fr); gap:8px; }
    .controls .row2 { display:grid; grid-template-columns:repeat(2, 1fr); gap:8px; }
    .controls .row1 { display:grid; grid-template-columns:1fr; gap:8px; }
    .btn { -webkit-tap-highlight-color: transparent; display:inline-flex; align-items:center; justify-content:center; text-align:center; width:100%; padding:12px 10px; border-radius:12px; border:2px solid var(--line); font-weight:900; font-size:15px; background:#ffffff; }
    .btn.tall { padding-top: 24px; padding-bottom: 24px; }
    .btn:active { transform: scale(0.98); }
    .btn.primary { background: var(--accent); border-color: var(--accent); color:white; }
    .btn.warn { background:#fee2e2; color:#7f1d1d; border-color:#fecaca; }

    button:disabled { opacity: 0.45; cursor: not-allowed; }

    .muted { color: var(--muted); font-size:12px; }

    @media (max-width: 860px) {
      .layout { flex-direction:column; }
      .controls-card { position:static; width:100%; }
      .controls { flex-direction:column; max-height:none; overflow:visible; }
      .teams { grid-template-columns:repeat(auto-fit, minmax(160px, 1fr)); }
    }
  </style>

  <!-- Firebase (compat) SDKs -->
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-database-compat.js"></script>

  <script>
    window.__firebaseReady = false;
    try {
      const firebaseConfig = {
        apiKey: "AIzaSyBOP7JnSA7lm0CVxUKlSi8nfXWwYokVZ9Q",
        authDomain: "flagfootball-4efca.firebaseapp.com",
        databaseURL: "https://flagfootball-4efca-default-rtdb.firebaseio.com",
        projectId: "flagfootball-4efca",
        storageBucket: "flagfootball-4efca.appspot.com",
        messagingSenderId: "207525608357",
        appId: "1:207525608357:web:54747b1ea6d1661bd4064c",
        measurementId: "G-J16S3S2N88"
      };

      if (window.firebase) {
        if (!firebase.apps || firebase.apps.length === 0) {
  firebase.initializeApp(firebaseConfig);
}

        window.__firebaseReady = true;
      }
    } catch (e) {
      console.warn("Firebase init failed:", e);
    }
  </script>


</head>
<body>
<script>
  window.onerror = function(msg, src, line, col, err){
    console.log("JS Error:", msg, src, line, col, err);
    var pre = document.createElement('pre');
    pre.textContent = "Error: " + msg + "\n" + src + ":" + line;
    pre.style.padding = "12px";
    pre.style.background = "#111";
    pre.style.color = "#f33";
    document.body.insertBefore(pre, document.body.firstChild);
  };
</script>

  <header class="topbar">
    <button class="menu-toggle" id="menuToggle" aria-label="Open menu" aria-expanded="false">☰</button>
    <div class="topbar-title">Flag Football Game Tracker</div>
    <div class="view-indicator" id="viewIndicator">Ref View</div>
  </header>

  <nav class="drawer" id="menuDrawer" aria-hidden="true">
    <div class="drawer-section">
      <h2>View</h2>
      <button class="drawer-item" data-view="ref" type="button">Ref view</button>
      <button class="drawer-item" data-view="player" type="button">Player view</button>
      <p class="drawer-note">Refs can update the score, clock, and stats. Players and spectators see a read-only dashboard.</p>
    </div>

    <div class="drawer-section">
      <h2>Live sync</h2>
      <form id="syncForm">
        <label for="syncGame">Game code</label>
        <input id="syncGame" name="game" type="text" placeholder="e.g. week1-field1" />
        <label style="display:flex;gap:8px;align-items:center;margin-top:6px;">
          <input id="joinAsWriter" type="checkbox" checked />
          <span>Join as ref (writer)</span>
        </label>
        <button class="save" type="submit">Save &amp; connect</button>
      </form>
      <button class="secondary" type="button" id="syncDisconnect">Disconnect</button>
      <p class="drawer-note">
        Enter a game code to join or host a game. First device to connect becomes the writer (ref).
      </p>
      <div class="sync-status" id="syncStatus" role="status">Offline</div>

    </div>
  </nav>
  <div class="drawer-backdrop" id="menuBackdrop" tabindex="-1" aria-hidden="true"></div>

  <div class="app">
    <h1>Flag Football Game Tracker</h1>

    <div class="layout">
      <div class="primary">
        <!-- Game Clock -->
        <div class="clock">
          <div class="left">
            <div class="muted">Game Clock</div>
            <div class="banner" id="timeoutBanner" style="display:none;">Timeout — <span id="timeoutTeam"></span> <span id="timeoutTime">1:00</span></div>
            <div class="banner" id="halftimeBanner" style="display:none;">Halftime — <span id="halftimeTime">2:00</span></div>
          </div>
          <div class="time" id="gameTime" title="Tap to edit when paused">15:00</div>
          <div class="clock-controls">
            <button class="btn" id="clockStartPause" data-role="ref-only">Start</button>
            <button class="btn" id="timeoutHome" data-role="ref-only">Timeout (Home)</button>
            <button class="btn" id="timeoutAway" data-role="ref-only">Timeout (Away)</button>
            <button class="btn" id="halftimeBtn" data-role="ref-only">Halftime</button>
          </div>
        </div>

        <!-- Teams -->
        <section class="teams" id="teams"></section>
      </div>

      <!-- Global Controls (shared by both teams) -->
      <aside class="controls-card">
        <div class="controls">
          <div class="label">Active team: <span id="activeTeamLabel">Home</span> — tap a team card to switch</div>
          <div class="row3">
            <button class="btn primary" id="g_score6" data-role="ref-only">+6</button>
            <button class="btn" id="g_score1" data-role="ref-only">+1</button>
            <button class="btn warn" id="g_scorem1" data-role="ref-only">-1</button>
          </div>
          <!-- Reordered: First Down, Guy Play, Rush, Girl Play -->
          <div class="row2">
            <button class="btn tall" id="g_downReset" data-role="ref-only">First Down</button>
            <button class="btn tall" id="g_guyPlay" data-role="ref-only">Guy Play</button>
          </div>
          <div class="row2">
            <button class="btn tall" id="g_rushm1" data-role="ref-only">Rush</button>
            <button class="btn tall" id="g_girlPlay" data-role="ref-only">Girl Play</button>
          </div>
          <div class="row1">
            <button class="btn tall warn" id="g_turnover" data-role="ref-only">Turnover</button>
          </div>
        </div>
      </aside>
    </div>
  </div>

<script>
/**********************
 * Storage & Migration
 **********************/
const STORAGE_KEY = 'flag_football_touch_v9';
const LEGACY_KEYS = ['flag_football_touch_v8','flag_football_touch_v7','flag_football_touch_v6','flag_football_touch_v5','flag_football_touch_v4'];
const VIEW_MODE_KEY = 'flag_football_touch_view_mode';
const REMOTE_CONFIG_KEY = 'flag_football_touch_remote_v1';

// NOTE: As of v9, girlPlay now represents "plays until required girl play" on a 0-2 scale
// 2 -> "2", 1 -> "1", 0 -> "Now". Previously (v8 and earlier) girlPlay was 1..3 rolling counter.

function serializeState(s){
  const teamSource = Array.isArray(s.teams) && s.teams.length ? s.teams : defaultState().teams;
  const game = s.game || {};
  const safe = {
    activeTeam: Math.max(0, Math.min(1, s.activeTeam != null ? s.activeTeam : 0)),
    teams: teamSource.map(t => ({
      name: t.name,
      score: t.score|0,
      downs: Math.min(4, Math.max(1, t.downs|0)) || 1,
      girlPlay: Math.min(2, Math.max(0, t.girlPlay|0)), // clamp to 0..2
      rushes: Math.max(0, t.rushes|0),
      timeouts: Math.max(0, t.timeouts|0)
    })),
    game: {
      seconds: Math.max(0, game.seconds|0) || 15*60,
      running: !!game.running,
      timeoutSecondsRemaining: Math.max(0, game.timeoutSecondsRemaining|0),
      timeoutTeam: game.timeoutTeam == null ? null : game.timeoutTeam,
      halftimeSecondsRemaining: Math.max(0, game.halftimeSecondsRemaining|0)
    }
  };
  if (safe.game.timeoutTeam != null) {
    safe.game.timeoutTeam = Math.max(0, Math.min(1, safe.game.timeoutTeam|0));
  } else {
    safe.game.timeoutTeam = null;
  }
  return safe;
}

function safeSave(){
  const payload = JSON.stringify(serializeState(state));
  try { localStorage.setItem(STORAGE_KEY, payload); }
  catch(e){
    try {
      const tiny = JSON.stringify({
        a: state.activeTeam,
        t: state.teams.map(t=>({n:t.name, s:t.score|0, d:t.downs|0, g:Math.min(2,Math.max(0,t.girlPlay|0)), r:t.rushes|0, o:t.timeouts|0})),
        g: {s: state.game.seconds|0}
      });
      localStorage.setItem(STORAGE_KEY, tiny);
    } catch(e2){ try{ localStorage.removeItem(STORAGE_KEY);}catch{} }
  }
}
let saveTimer=null; function scheduleSave(){ clearTimeout(saveTimer); saveTimer = setTimeout(safeSave, 400); }

function requestPersist(){
  scheduleSave();
  scheduleRemotePush();
}

function renderAndPersist(){
  render();
  requestPersist();
}

/**********************
 * App State
 **********************/
const $ = (sel) => document.querySelector(sel);
const $$ = (sel) => Array.from(document.querySelectorAll(sel));

const defaultState = () => ({
  activeTeam: 0,
  teams: [
    { name: 'Home', score: 0, downs: 1, girlPlay: 2, rushes: 2, timeouts: 3 }, // start at 2 plays until girl
    { name: 'Away', score: 0, downs: 1, girlPlay: 2, rushes: 2, timeouts: 3 }
  ],
  game: { seconds: 15*60, running: false, timeoutSecondsRemaining: 0, timeoutTeam: null, halftimeSecondsRemaining: 0 }
});

const VALUE_RULES = {
  score: { label: 'Score', min: 0, minMessage: 'Score must be 0 or higher', hint: 'Enter 0 or higher' },
  downs: { label: 'Down', min: 1, max: 4, minMessage: 'Down must be between 1 and 4', maxMessage: 'Down must be between 1 and 4', hint: 'Use values from 1-4' },
  girlPlay: { label: 'Girl Play In', min: 0, max: 2, minMessage: 'Girl Play In must be between 0 and 2', maxMessage: 'Girl Play In must be between 0 and 2', hint: '0 = Now, 2 = Two plays' },
  rushes: { label: 'Rushes', min: 0, minMessage: 'Rushes must be 0 or higher', hint: 'Enter 0 or higher' },
  timeouts: { label: 'Timeouts', min: 0, minMessage: 'Timeouts must be 0 or higher', hint: 'Enter 0 or higher' }
};

function migrateGirlPlay(oldVal){
  // v8 style (1..3 rolling) -> v9 remaining (2..0)
  // Map: 1 -> 2, 2 -> 1, 3 -> 0
  if (typeof oldVal !== 'number') return 2;
  if (oldVal <= 1) return 2;
  if (oldVal === 2) return 1;
  return 0; // 3 or higher
}

function inflate(obj){
  const base = defaultState(); if (!obj) return base;
  try {
    const activeTeamRaw = obj.activeTeam != null ? obj.activeTeam : (obj.a != null ? obj.a : 0);
    const fallbackTeams = base.teams;
    const teamsSource = Array.isArray(obj.teams) && obj.teams.length
      ? obj.teams
      : (Array.isArray(obj.t) && obj.t.length ? obj.t : fallbackTeams);
    base.teams = teamsSource.map((t,i)=>{
      const prev = fallbackTeams[i] || {};
      // Accept both schemas for girlPlay
      const gp = (t.girlPlay == null) ? prev.girlPlay : t.girlPlay;
      const girlV9 = (gp>=0 && gp<=2) ? gp : migrateGirlPlay(gp);
      return {
        name: t.name != null ? t.name : (t.n != null ? t.n : (prev.name != null ? prev.name : 'Team')),
        score: t.score != null ? t.score : (t.s != null ? t.s : 0),
        downs: t.downs != null ? t.downs : (t.d != null ? t.d : 1),
        girlPlay: girlV9,
        rushes: t.rushes != null ? t.rushes : (t.r != null ? t.r : 2),
        timeouts: t.timeouts != null ? t.timeouts : (t.o != null ? t.o : 3)
      };
    });
    const teamsLength = base.teams.length || fallbackTeams.length;
    const activeTeamNum = Number(activeTeamRaw);
    const normalizedActiveTeam = Number.isFinite(activeTeamNum)
      ? Math.max(0, Math.min(teamsLength > 0 ? teamsLength - 1 : 0, Math.floor(activeTeamNum)))
      : 0;
    base.activeTeam = normalizedActiveTeam;
    const g = obj.game != null ? obj.game : (obj.g != null ? obj.g : {});
    const secondsSource = g.seconds != null ? g.seconds : (g.s != null ? g.s : 15*60);
    base.game.seconds = Math.max(0, secondsSource);
    base.game.running = !!g.running;
    const timeoutSeconds = g.timeoutSecondsRemaining != null ? g.timeoutSecondsRemaining : (g.tr != null ? g.tr : 0);
    base.game.timeoutSecondsRemaining = Math.max(0, timeoutSeconds);
    if (g.timeoutTeam == null) base.game.timeoutTeam = null;
    else base.game.timeoutTeam = Math.max(0, Math.min(1, g.timeoutTeam|0));
    const halftimeSeconds = g.halftimeSecondsRemaining != null ? g.halftimeSecondsRemaining : (g.hr != null ? g.hr : 0);
    base.game.halftimeSecondsRemaining = Math.max(0, halftimeSeconds);
  } catch {}
  return base;
}

function loadMigrated(){
  try { const raw = localStorage.getItem(STORAGE_KEY); if (raw) return inflate(JSON.parse(raw)); } catch {}
  for (const k of LEGACY_KEYS){
    try {
      const raw = localStorage.getItem(k); if (!raw) continue;
      const migrated = inflate(JSON.parse(raw));
      localStorage.setItem(STORAGE_KEY, JSON.stringify(serializeState(migrated)));
      try { localStorage.removeItem(k); } catch {}
      return migrated;
    } catch {}
  }
  return null;
}

function loadViewMode(){
  try {
    const raw = localStorage.getItem(VIEW_MODE_KEY);
    if (raw === 'ref' || raw === 'player') return raw;
  } catch {}
  return 'ref';
}

function saveViewMode(mode){
  try { localStorage.setItem(VIEW_MODE_KEY, mode); } catch {}
}

let state = loadMigrated() || defaultState();
let timeoutTimer = null; // 1:00 timeout
let halftimeTimer = null; // 2:00 halftime
let clockTimer = null;    // game clock
let activeValueEditor = null;
let viewMode = loadViewMode();

const remoteSync = {
  config: loadRemoteConfig(),
  source: null,
  status: 'idle',
  lastError: null,
  pushTimer: null,
  lastPushedAt: 0,
  applying: false,
  connected: false,
  pushing: false,
  pendingPush: false,

  // New flag: when true, skip whole-state pushes and use transactions instead
  useTransactions: true
};


/**********************
 * Rendering
 **********************/
function fmt(sec){ const m=Math.floor(sec/60); const s=sec%60; const padded = ('0' + s).slice(-2); return `${m}:${padded}`; }
function fmtGirl(val){ return val===0 ? 'Now' : String(val); }

function render(){
  document.body.dataset.view = viewMode;
  const indicator = $('#viewIndicator');
  if (indicator) indicator.textContent = viewMode === 'ref' ? 'Ref View' : 'Player View';
  $$('#menuDrawer .drawer-item').forEach(btn => btn.classList.toggle('active', btn.dataset.view === viewMode));
  const isRef = viewMode === 'ref';
  $$('button[data-role="ref-only"]').forEach(btn => { btn.disabled = !isRef; });

  // Clock & banners
  $('#gameTime').textContent = fmt(state.game.seconds);
  if (state.game.timeoutSecondsRemaining>0){
    $('#timeoutBanner').style.display='';
    const timeoutTeamIndex = state.game.timeoutTeam;
    let timeoutName = '';
    if (timeoutTeamIndex != null && state.teams[timeoutTeamIndex]) {
      timeoutName = state.teams[timeoutTeamIndex].name;
    }
    $('#timeoutTeam').textContent = timeoutName;
    $('#timeoutTime').textContent = fmt(state.game.timeoutSecondsRemaining);
  } else { $('#timeoutBanner').style.display='none'; }
  if (state.game.halftimeSecondsRemaining>0){
    $('#halftimeBanner').style.display='';
    $('#halftimeTime').textContent = fmt(state.game.halftimeSecondsRemaining);
  } else { $('#halftimeBanner').style.display='none'; }

  $('#clockStartPause').textContent = state.game.running ? 'Pause' : 'Start';
  const activeTeam = state.teams[state.activeTeam] || state.teams[0];
  const activeTeamLabel = $('#activeTeamLabel');
  if (activeTeamLabel && activeTeam) {
    activeTeamLabel.textContent = activeTeam.name;
  }
  renderTeams();
}

function renderTeams(){
  const editingVal = document.querySelector('.val.editing');
  let restoreEdit = null;
  if (editingVal) {
    const { team, kind } = editingVal.dataset;
    const input = editingVal.querySelector('input');
    if (team != null && kind && input) {
      restoreEdit = {
        team: Number(team),
        kind,
        value: input.value,
        selectionStart: input.selectionStart != null ? input.selectionStart : input.value.length,
        selectionEnd: input.selectionEnd != null ? input.selectionEnd : input.value.length
      };
    }
  }

  const editingEnabled = viewMode === 'ref';
  if (!editingEnabled && activeValueEditor) {
    try { activeValueEditor(false); } catch {}
  }
  activeValueEditor = null;
  const host = $('#teams'); host.innerHTML = '';
  state.teams.forEach((t, idx) => {
    const sec = document.createElement('section'); sec.className = 'team' + (state.activeTeam===idx?' active':'');
    if (editingEnabled){
      sec.addEventListener('click', ()=>{ state.activeTeam = idx; renderAndPersist(); });
    }

    const header = document.createElement('header');
    const nameSpan = document.createElement('span'); nameSpan.className = 'name'; nameSpan.textContent = t.name;
    if (editingEnabled){
      nameSpan.addEventListener('click', (ev)=>{ ev.stopPropagation(); beginEditName(idx, nameSpan); });
    }
    header.appendChild(nameSpan);

    const stats = document.createElement('div'); stats.className = 'stats';
    const score = document.createElement('div'); score.className = 'stat full'; score.innerHTML = `<label>Score</label><div class="val" data-kind="score" data-team="${idx}">${t.score}</div>`;
    const down = document.createElement('div'); down.className='stat'; down.innerHTML = `<label>Down</label><div class="val" data-kind="downs" data-team="${idx}">${t.downs}</div>`;
    const girl = document.createElement('div'); girl.className='stat'; girl.innerHTML = `<label>Girl Play In</label><div class="val" data-kind="girlPlay" data-team="${idx}">${fmtGirl(t.girlPlay)}</div>`;
    const rush = document.createElement('div'); rush.className='stat'; rush.innerHTML = `<label>Rushes</label><div class="val" data-kind="rushes" data-team="${idx}">${t.rushes}</div>`;
    const to = document.createElement('div'); to.className='stat'; to.innerHTML = `<label>Timeouts</label><div class="val" data-kind="timeouts" data-team="${idx}">${t.timeouts}</div>`;

    [score,down,girl,rush,to].forEach(el=>stats.appendChild(el));

    sec.appendChild(header); sec.appendChild(stats); host.appendChild(sec);
  });

  if (editingEnabled){
    $$('#teams .val').forEach(v => {
      v.addEventListener('click', (ev)=>{ ev.stopPropagation(); beginEditValue(v, v.dataset.kind, +v.dataset.team); });
    });
  }

  if (restoreEdit && editingEnabled) {
    const valEl = host.querySelector(`.val[data-team="${restoreEdit.team}"][data-kind="${restoreEdit.kind}"]`);
    if (valEl) {
      beginEditValue(valEl, restoreEdit.kind, restoreEdit.team, { skipCancelExisting: true, restore: restoreEdit });
    }
  }
}

/**********************
 * Remote Sync (Firebase Realtime Database via SDK)
 **********************/
let auth = null, db = null;
if (window.__firebaseReady && window.firebase) {
  try {
    auth = firebase.auth();
    db   = firebase.database();
  } catch (e) {
    console.warn('Firebase SDK present but init failed:', e);
  }
} else {
  console.warn('Firebase SDK not available; running local-only.');
}




function remoteConfigured(){ return !!(remoteSync.config && remoteSync.config.game); }

// Persist only the game code locally
function saveRemoteConfig(cfg){ try { localStorage.setItem(REMOTE_CONFIG_KEY, JSON.stringify({ game: cfg.game, lastKnown: cfg.lastKnown || null })); } catch {} }
function loadRemoteConfig(){
  try {
    const raw = localStorage.getItem(REMOTE_CONFIG_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== 'object' || !parsed.game) return null;
    return { game: parsed.game, lastKnown: parsed.lastKnown || null };
  } catch {}
  return null;
}
function clearRemoteConfig(){ try { localStorage.removeItem(REMOTE_CONFIG_KEY); } catch {} }

remoteSync.config = loadRemoteConfig();
remoteSync.canWrite = false;

function updateRemoteStatus(){
  const el = $('#syncStatus'); if (!el) return;
  if (!remoteConfigured()){ el.textContent = 'Offline'; return; }
  if (remoteSync.status === 'connecting') el.textContent = `Connecting to ${remoteSync.config.game}…`;
  else if (remoteSync.status === 'connected'){
    el.textContent = `Connected • ${remoteSync.config.game} • ${remoteSync.canWrite ? 'Ref (writer)' : 'Viewer'}`;
  } else if (remoteSync.status === 'error'){
    const msg = remoteSync.lastError && (remoteSync.lastError.message || String(remoteSync.lastError));
    el.textContent = `Sync error — ${msg || 'check connection or rules'}`;
  } else {
    el.textContent = 'Ready to connect';
  }
}

function populateSyncForm(){
  const form = $('#syncForm'); if (!form) return;
  const cfg = remoteSync.config || {};
  if (form.game) form.game.value = cfg.game || '';
}

// Throttled remote push
let lastPushMs = 0;
function scheduleRemotePush(){
  if (remoteSync.useTransactions) return;
  if (!db || !auth) return;
  if (!remoteConfigured() || viewMode !== 'ref' || remoteSync.applying || !remoteSync.canWrite) return;
  const now = Date.now();
  const ticking = state.game.running || state.game.timeoutSecondsRemaining>0 || state.game.halftimeSecondsRemaining>0;
  const minGap = ticking ? 2500 : 250;

  if (now - lastPushMs < minGap) {
    remoteSync.pendingPush = true;
    if (!remoteSync.pushTimer) {
      remoteSync.pushTimer = setTimeout(()=>{ remoteSync.pushTimer=null; pushRemoteNow(); }, minGap - (now - lastPushMs));
    }
    return;
  }
  if (remoteSync.pushTimer) clearTimeout(remoteSync.pushTimer);
  remoteSync.pushTimer = setTimeout(()=>{ remoteSync.pushTimer=null; pushRemoteNow(); }, ticking ? 400 : 200);
}

function pushRemoteNow(){
  if (!db || !auth) return;
  if (!remoteConfigured() || !remoteSync.canWrite) return;
  remoteSync.pushing = true;

  const gameRef = db.ref(`games/${remoteSync.config.game}`);
  const payload = { state: serializeState(state), updatedAt: firebase.database.ServerValue.TIMESTAMP };

  gameRef.update(payload)
    .then(()=>{ remoteSync.status='connected'; remoteSync.connected=true; remoteSync.lastError=null; lastPushMs=Date.now(); })
    .catch(err=>{ remoteSync.status='error'; remoteSync.connected=false; remoteSync.lastError=String(err && err.message ? err.message : err); })
    .finally(()=>{
      remoteSync.pushing=false;
      if (remoteSync.pendingPush){ remoteSync.pendingPush=false; pushRemoteNow(); }
      updateRemoteStatus();
    });
}

// Replace your current handleRemotePayload with this
function handleRemotePayload(raw){
  if (!raw) return;
  const body = raw.state != null ? raw.state : raw;
  if (!body) return;
  remoteSync.applying = true;
  try {
    // inflate() already normalizes/clamps to our expected shape
    state = inflate(body);
    render();              // <- re-render UI from remote state
  } finally {
    remoteSync.applying = false;
  }
}


function disconnectRemote(){
  if (remoteSync.source){ try { remoteSync.source.off(); } catch {} }
  remoteSync.source = null;
  remoteSync.connected = false;
  if (remoteSync.pushTimer){ clearTimeout(remoteSync.pushTimer); remoteSync.pushTimer=null; }
  remoteSync.pendingPush = false;
  updateRemoteStatus();
}

// Is current user listed as a writer?
async function isCurrentUserWriter(game) {
  const uid = (auth && auth.currentUser) ? auth.currentUser.uid : null;

  if (!uid) return false;
  try {
    const snap = await db.ref(`games/${game}/meta/writers/${uid}`).get();
    return snap.val() === true;
  } catch {
    return false;
  }
}

// Add/remove current user to writers set
async function joinWriters(game) {
  const uid = (auth && auth.currentUser) ? auth.currentUser.uid : null;

  if (!uid) return false;
  await db.ref(`games/${game}/meta/writers/${uid}`).set(true);
  return true;
}
async function leaveWriters(game) {
  const uid = (auth && auth.currentUser) ? auth.currentUser.uid : null;
  if (!uid) return;
  await db.ref(`games/${game}/meta/writers/${uid}`).set(null);
}

function isOnlineWriter(){
  return remoteConfigured() && remoteSync.canWrite && db && auth && auth.currentUser;
}

function txnField(path, mutateFn) {
  const ref = db.ref(`games/${remoteSync.config.game}/state/${path}`);
  return ref.transaction(curr => mutateFn(curr));
}

function txnState(mutateFn){
  const ref = db.ref(`games/${remoteSync.config.game}/state`);
  return ref.transaction(s => {
    // Start from a valid shape if missing
    if (!s) s = serializeState(defaultState());
    // Let caller mutate the object in place
    mutateFn(s);
    // IMPORTANT: return the mutated object, not undefined
    return s;
  })
  .then(res => { console.log('[txnState] committed:', res.committed); return res; })
  .catch(e => { console.warn('[txnState:err]', e); throw e; });
}

async function seedStateIfMissing(game){
  if (!remoteSync.canWrite) return; // only a writer seeds
  const ref = db.ref(`games/${game}/state`);
  await ref.transaction(s => {
    // If empty, initialize default; otherwise leave as-is
    return s || serializeState(defaultState());
  });
}


async function connectRemote(){
  // reset any prior listeners/session state
  disconnectRemote();

  // basic guards
  if (!remoteConfigured()){
    remoteSync.status = 'idle';
    updateRemoteStatus();
    return;
  }
  if (!db || !auth){
    remoteSync.status = 'error';
    remoteSync.lastError = 'Firebase SDK not ready';
    updateRemoteStatus();
    return;
  }

  remoteSync.status = 'connecting';
  updateRemoteStatus();

  // 1) sign in anonymously if needed
  try {
    if (!auth.currentUser) await auth.signInAnonymously();
  } catch (err) {
    remoteSync.status = 'error';
    remoteSync.lastError = err;
    updateRemoteStatus();
    return;
  }

  // 2) writer intent (multi-writer)
  const game = remoteSync.config.game;
  var _el = document.getElementById('joinAsWriter');
const wantsWriter = (_el && typeof _el.checked !== 'undefined') ? _el.checked : true;

  try {
    if (wantsWriter) {
      await joinWriters(game);     // add self to writers set
    } else {
      await leaveWriters(game);    // ensure we are not listed as writer
    }
  } catch (err) {
    // proceed as viewer if writer join fails
    console.warn('[sync] writer join/leave failed, continuing as viewer', err);
  }

  // 3) establish writer capability
  try {
    remoteSync.canWrite = await isCurrentUserWriter(game);
  } catch {
    remoteSync.canWrite = false;
  }

  // 4) seed state once if missing (only writers)
  try {
    if (remoteSync.canWrite) {
      await seedStateIfMissing(game);
    }
  } catch (err) {
    console.warn('[sync] seedStateIfMissing failed', err);
  }

  // 5) live listener (to both meta + state)
  const gameRef = db.ref(`games/${game}`);
  const handler = gameRef.on('value', (snap) => {
    const data = snap.val();
    if (data && data.state) handleRemotePayload(data);
    remoteSync.connected = true;
    remoteSync.status = 'connected';
    updateRemoteStatus();
  });
  remoteSync.source = { off: () => gameRef.off('value', handler) };

  updateRemoteStatus();
}



function beginEditName(idx, spanEl){
  if (viewMode !== 'ref') return;
  if (spanEl.classList.contains('editing')) return;

  spanEl.classList.add('editing');
  const input = document.createElement('input');
  input.className = 'name-input';
  input.value = state.teams[idx].name;

  spanEl.replaceWith(input);
  input.focus();
  input.setSelectionRange(0, input.value.length);

  const finish = async (commit) => {
    const newSpan = document.createElement('span');
    newSpan.className = 'name';

    if (commit) {
      const newName = (input.value || '').trim() || state.teams[idx].name;

      // Update local state immediately for snappy UI
      state.teams[idx].name = newName;

      // If we’re an online writer, sync the name to Firebase
      if (isOnlineWriter()) {
        try {
          await txnField(`teams/${idx}/name`, () => newName);
        } catch (e) {
          console.warn('[name sync] failed, keeping local value', e);
        }
      }

      newSpan.textContent = newName;
      newSpan.addEventListener('click', (ev)=>{ ev.stopPropagation(); beginEditName(idx, newSpan); });
      input.replaceWith(newSpan);

      renderAndPersist();
      return;
    }

    // Cancel edit
    newSpan.textContent = state.teams[idx].name;
    newSpan.addEventListener('click', (ev)=>{ ev.stopPropagation(); beginEditName(idx, newSpan); });
    input.replaceWith(newSpan);
    render();
  };

  input.addEventListener('blur', () => finish(true));
  input.addEventListener('keydown', (e)=>{ if(e.key==='Enter') finish(true); if(e.key==='Escape') finish(false); });
}


function beginEditValue(valEl, kind, teamIdx, opts = {}){
  if (viewMode !== 'ref') return;
  if (!valEl || valEl.classList.contains('editing')) return;
  const team = state.teams[teamIdx];
  const rules = VALUE_RULES[kind];
  if (!team || !rules) return;

  if (activeValueEditor && !opts.skipCancelExisting) activeValueEditor(false);

  const originalData = team[kind] != null ? team[kind] : '';
  const originalDisplay = kind==='girlPlay' ? fmtGirl(team.girlPlay) : String(originalData);
  const originalValue = String(originalData);
  let startingValue = originalValue;
  if (opts.restore && Object.prototype.hasOwnProperty.call(opts.restore, 'value')) {
    startingValue = opts.restore.value;
  }

  valEl.classList.add('editing');
  valEl.textContent = '';

  const input = document.createElement('input');
  input.className = 'val-input';
  input.type = 'text';
  input.inputMode = 'numeric';
  input.pattern = '[0-9]*';
  input.autocomplete = 'off';
  input.spellcheck = false;
  input.value = startingValue;
  input.setAttribute('aria-label', `${rules.label} for ${team.name}`);
  valEl.appendChild(input);

  const errorId = `val-error-${teamIdx}-${kind}`;
  input.setAttribute('aria-describedby', errorId);
  const error = document.createElement('div');
  error.className = 'val-error';
  error.id = errorId;
  error.setAttribute('role','alert');
  error.setAttribute('aria-live','polite');
  valEl.appendChild(error);

  const focusInput = () => {
    input.focus();
    if (opts.restore && opts.restore.selectionStart != null) {
      const restoreStart = opts.restore.selectionStart;
      const restoreEnd = opts.restore.selectionEnd != null ? opts.restore.selectionEnd : restoreStart;
      try { input.setSelectionRange(restoreStart, restoreEnd); }
      catch {}
    } else if (typeof input.select === 'function') {
      input.select();
    }
  };
  const showError = (msg) => {
    error.textContent = msg || '';
    error.classList.toggle('visible', !!msg);
    input.classList.toggle('invalid', !!msg);
  };

  let closed = false;
  const finish = (commit) => {
    if (closed) return;
    if (!commit){
      closed = true;
      activeValueEditor = null;
      showError('');
      valEl.classList.remove('editing');
      valEl.textContent = originalDisplay;
      return;
    }

    const raw = input.value.trim();
    if (!raw){ showError('Enter a number'); focusInput(); return; }
    if (!/^-?\d+$/.test(raw)){ showError('Use whole numbers only'); focusInput(); return; }
    const nextVal = parseInt(raw, 10);
    if (Number.isNaN(nextVal)){ showError('Enter a number'); focusInput(); return; }
    if (rules.min != null && nextVal < rules.min){ showError(rules.minMessage || `${rules.label} must be ≥ ${rules.min}`); focusInput(); return; }
    if (rules.max != null && nextVal > rules.max){ showError(rules.maxMessage || `${rules.label} must be ≤ ${rules.max}`); focusInput(); return; }

    closed = true;
    activeValueEditor = null;
    showError('');
    team[kind] = nextVal;
    valEl.classList.remove('editing');
    valEl.textContent = kind==='girlPlay' ? fmtGirl(nextVal) : String(nextVal);
    renderAndPersist();
  };

  activeValueEditor = finish;

  input.addEventListener('click', (e)=>e.stopPropagation());
  input.addEventListener('keydown', (e)=>{
    if (e.key === 'Enter'){ e.preventDefault(); finish(true); }
    else if (e.key === 'Escape'){ e.preventDefault(); finish(false); }
  });
  input.addEventListener('blur', ()=>{
    setTimeout(()=>{
      if (!valEl.isConnected) return;
      const active = document.activeElement;
      if (!valEl.contains(active)) finish(true);
    }, 20);
  });
  input.addEventListener('input', ()=>{ if (error.textContent) showError(''); });

  setTimeout(()=>{ focusInput(); }, 0);
}

/**********************
 * Global Controls
 **********************/
$('#g_score6').addEventListener('click', ()=>{
  if (isOnlineWriter()) {
    txnField(`teams/${state.activeTeam}/score`, v => (v|0) + 6);
  } else if (viewMode === 'ref') {
    state.teams[state.activeTeam].score += 6; renderAndPersist();
  }
});

$('#g_score1').addEventListener('click', ()=>{
  if (isOnlineWriter()) {
    txnField(`teams/${state.activeTeam}/score`, v => (v|0) + 1);
  } else if (viewMode === 'ref') {
    state.teams[state.activeTeam].score += 1; renderAndPersist();
  }
});

$('#g_scorem1').addEventListener('click', ()=>{
  if (isOnlineWriter()) {
    txnField(`teams/${state.activeTeam}/score`, v => Math.max(0, (v|0) - 1));
  } else if (viewMode === 'ref') {
    const t = state.teams[state.activeTeam]; t.score = Math.max(0, t.score - 1); renderAndPersist();
  }
});


// Guy/Girl play (v9 semantics)
$('#g_guyPlay').addEventListener('click', ()=>{
  if (isOnlineWriter()) {
    txnState(s => {
      const t = s.teams[s.activeTeam];
      t.downs = t.downs >= 4 ? 1 : (t.downs|0) + 1;
      t.girlPlay = Math.max(0, (t.girlPlay|0) - 1);
      return s;
    });
  } else if (viewMode === 'ref') {
    const t = state.teams[state.activeTeam];
    t.downs = t.downs >= 4 ? 1 : t.downs + 1;
    t.girlPlay = Math.max(0, (t.girlPlay|0) - 1);
    renderAndPersist();
  }
});

$('#g_girlPlay').addEventListener('click', ()=>{
  if (isOnlineWriter()) {
    txnState(s => {
      const t = s.teams[s.activeTeam];
      t.girlPlay = 2;
      t.downs = t.downs >= 4 ? 1 : (t.downs|0) + 1;
      return s;
    });
  } else if (viewMode === 'ref') {
    const t = state.teams[state.activeTeam];
    t.girlPlay = 2;
    t.downs = t.downs >= 4 ? 1 : t.downs + 1;
    renderAndPersist();
  }
});


// First Down
$('#g_downReset').addEventListener('click', ()=>{
  if (isOnlineWriter()) {
    txnField(`teams/${state.activeTeam}/downs`, () => 1);
  } else if (viewMode === 'ref') {
    state.teams[state.activeTeam].downs = 1; renderAndPersist();
  }
});


// Turnover
$('#g_turnover').addEventListener('click', ()=>{
  if (isOnlineWriter()) {
    txnState(s => {
      const cur = s.activeTeam;
      const next = cur === 0 ? 1 : 0;
      s.teams[cur].downs = 1;
      s.teams[cur].girlPlay = 2;
      s.activeTeam = next;
      return s;
    });
  } else if (viewMode === 'ref') {
    const cur = state.activeTeam;
    state.teams[cur].downs = 1;
    state.teams[cur].girlPlay = 2;
    state.activeTeam = cur === 0 ? 1 : 0;
    renderAndPersist();
  }
});


// Rush (defense)
$('#g_rushm1').addEventListener('click', ()=>{
  if (isOnlineWriter()) {
    const def = state.activeTeam === 0 ? 1 : 0;
    txnField(`teams/${def}/rushes`, v => Math.max(0, (v|0) - 1));
  } else if (viewMode === 'ref') {
    const def = state.activeTeam === 0 ? 1 : 0;
    state.teams[def].rushes = Math.max(0, state.teams[def].rushes - 1);
    renderAndPersist();
  }
});


/**********************
 * Clock, Timeout & Halftime
 **********************/
function clearTimeoutMode(){
  if (timeoutTimer){ clearInterval(timeoutTimer); timeoutTimer=null; }
  state.game.timeoutSecondsRemaining=0;
  state.game.timeoutTeam=null;
}
function clearHalftimeMode(){
  if (halftimeTimer){ clearInterval(halftimeTimer); halftimeTimer=null; }
  state.game.halftimeSecondsRemaining=0;
}

function startClock(){
  if (viewMode !== 'ref') return;

  // Writer path: drive seconds in Firebase
  if (isOnlineWriter()){
    // clear timeout/halftime state first, in DB
    txnState(s => {
      s.game.timeoutSecondsRemaining = 0;
      s.game.timeoutTeam = null;
      s.game.halftimeSecondsRemaining = 0;
      s.game.running = true;
    });

    if (clockTimer) return;
    // tick seconds down in Firebase once per second
    clockTimer = setInterval(()=>{
      txnField('game/seconds', v => {
        const next = Math.max(0, (v|0) - 1);
        return next;
      }).then(res => {
        // if hit 0, stop the clock
        var after;
if (res && res.snapshot && typeof res.snapshot.val === 'function') {
  after = res.snapshot.val();
}
        if ((after ?? state.game.seconds) <= 0) pauseClock();
      }).catch(()=>{ /* ignore transient failures */ });
    }, 1000);
    return;
  }

  // Viewer/local path
  if (state.game.timeoutSecondsRemaining>0) clearTimeoutMode();
  if (state.game.halftimeSecondsRemaining>0) clearHalftimeMode();
  if (clockTimer) return;
  state.game.running = true;
  renderAndPersist();
  clockTimer = setInterval(()=>{
    if (state.game.seconds>0){
      state.game.seconds--;
      renderAndPersist();
    } else {
      pauseClock();
    }
  }, 1000);
}

function pauseClock(){
  if (clockTimer){ clearInterval(clockTimer); clockTimer=null; }
  if (isOnlineWriter()){
    txnField('game/running', () => false);
    return;
  }
  state.game.running=false;
  renderAndPersist();
}

function toggleStartPause(){
  if (viewMode !== 'ref') return;
  if (isOnlineWriter()){
    // Flip running in DB; local timer start/stop follows
    const currentlyRunning = state.game.running;
    if (currentlyRunning) pauseClock(); else startClock();
    return;
  }
  state.game.running ? pauseClock() : startClock();
}


function startTimeout(teamIdx){
  if (viewMode !== 'ref') return;
  if (isOnlineWriter()){
    // seed 60s timeout and decrement team timeouts
    txnState(s => {
      const t = s.teams[teamIdx];
      if ((t.timeouts|0) <= 0) return s; // no-op if none left
      t.timeouts = Math.max(0, (t.timeouts|0) - 1);
      s.game.running = false;
      s.game.halftimeSecondsRemaining = 0;
      s.game.timeoutTeam = teamIdx;
      s.game.timeoutSecondsRemaining = 60;
      return s;
    });
    if (timeoutTimer) clearInterval(timeoutTimer);
    timeoutTimer = setInterval(()=>{
      txnField('game/timeoutSecondsRemaining', v => Math.max(0, (v|0) - 1))
        .then(res => {
          // stop when zero
          var after;
if (res && res.snapshot && typeof res.snapshot.val === 'function') {
  after = res.snapshot.val();
}
          if ((after ?? state.game.timeoutSecondsRemaining) <= 0){
            clearInterval(timeoutTimer);
            timeoutTimer = null;
            // clear timeout fields in DB
            txnState(s => { s.game.timeoutSecondsRemaining=0; s.game.timeoutTeam=null; return s; });
          }
        }).catch(()=>{});
    }, 1000);
    return;
  }

  // local fallback
  if (timeoutTimer || state.game.timeoutSecondsRemaining>0) return;
  const t = state.teams[teamIdx]; if (t.timeouts<=0) return;
  t.timeouts--; pauseClock(); clearHalftimeMode();
  state.game.timeoutSecondsRemaining = 60; state.game.timeoutTeam = teamIdx;
  timeoutTimer = setInterval(()=>{
    if (state.game.timeoutSecondsRemaining>0){
      state.game.timeoutSecondsRemaining--;
      renderAndPersist();
    } else {
      clearTimeoutMode();
      renderAndPersist();
    }
  },1000);
  renderAndPersist();
}

function startHalftime(){
  if (viewMode !== 'ref') return;
  if (isOnlineWriter()){
    // reset team counters, set halftime 120s
    txnState(s => {
      s.game.running = false;
      s.game.timeoutSecondsRemaining = 0;
      s.game.timeoutTeam = null;
      s.game.seconds = 15*60;
      s.game.halftimeSecondsRemaining = 120;
      s.teams.forEach(t=>{ t.downs=1; t.girlPlay=2; t.rushes=2; t.timeouts=3; });
      return s;
    });
    if (halftimeTimer) clearInterval(halftimeTimer);
    halftimeTimer = setInterval(()=>{
      txnField('game/halftimeSecondsRemaining', v => Math.max(0, (v|0) - 1))
        .then(res => {
          var after;
if (res && res.snapshot && typeof res.snapshot.val === 'function') {
  after = res.snapshot.val();
}
          if ((after ?? state.game.halftimeSecondsRemaining) <= 0){
            clearInterval(halftimeTimer);
            halftimeTimer = null;
            txnField('game/halftimeSecondsRemaining', () => 0);
          }
        }).catch(()=>{});
    }, 1000);
    return;
  }

  // local fallback
  pauseClock(); clearTimeoutMode();
  state.teams.forEach(t=>{ t.downs=1; t.girlPlay=2; t.rushes=2; t.timeouts=3; });
  state.game.seconds = 15*60;
  state.game.halftimeSecondsRemaining = 120;
  if (halftimeTimer) clearInterval(halftimeTimer);
  halftimeTimer = setInterval(()=>{
    if (state.game.halftimeSecondsRemaining>0){
      state.game.halftimeSecondsRemaining--;
      renderAndPersist();
    } else {
      clearHalftimeMode();
      renderAndPersist();
    }
  }, 1000);
  renderAndPersist();
}

$('#clockStartPause').addEventListener('click', toggleStartPause);
$('#timeoutHome').addEventListener('click', ()=> startTimeout(0));
$('#timeoutAway').addEventListener('click', ()=> startTimeout(1));
$('#halftimeBtn').addEventListener('click', startHalftime);

// Edit time when paused
$('#gameTime').addEventListener('click', ()=>{
  if (viewMode !== 'ref') return;
  if (state.game.running || state.game.timeoutSecondsRemaining>0 || state.game.halftimeSecondsRemaining>0) return;
  const current = fmt(state.game.seconds);
  const input = prompt('Set game clock (MM:SS):', current);
  if (!input) return;
  const m = input.match(/^(\d{1,2}):(\d{2})$/);
  if (!m) return alert('Please enter time as MM:SS');
  const mm = parseInt(m[1],10), ss = parseInt(m[2],10);
  if (ss>59) return alert('Seconds must be 00-59');
  const next = Math.max(0, mm*60 + ss);

  if (isOnlineWriter()){
    txnField('game/seconds', () => next);
  } else {
    state.game.seconds = next;
    renderAndPersist();
  }
});

/**********************
 * Menu & View Switching
 **********************/
const menuToggleBtn = $('#menuToggle');
const menuDrawer = $('#menuDrawer');
const menuBackdrop = $('#menuBackdrop');

function openMenu(){
  document.body.classList.add('menu-open');
  if (menuDrawer) menuDrawer.setAttribute('aria-hidden', 'false');
  if (menuBackdrop) menuBackdrop.setAttribute('aria-hidden', 'false');
  if (menuToggleBtn) menuToggleBtn.setAttribute('aria-expanded', 'true');
  populateSyncForm();
}

function closeMenu(){
  document.body.classList.remove('menu-open');
  if (menuDrawer) menuDrawer.setAttribute('aria-hidden', 'true');
  if (menuBackdrop) menuBackdrop.setAttribute('aria-hidden', 'true');
  if (menuToggleBtn) menuToggleBtn.setAttribute('aria-expanded', 'false');
}

function toggleMenu(){
  if (document.body.classList.contains('menu-open')) closeMenu();
  else openMenu();
}

function setViewMode(mode){
  const next = mode === 'player' ? 'player' : 'ref';
  if (viewMode === next) return;
  viewMode = next;
  saveViewMode(viewMode);
  if (viewMode !== 'ref' && remoteSync.pushTimer){
    clearTimeout(remoteSync.pushTimer);
    remoteSync.pushTimer = null;
  }
  closeMenu();
  render();
}

if (menuToggleBtn) menuToggleBtn.addEventListener('click', toggleMenu);
if (menuBackdrop) menuBackdrop.addEventListener('click', closeMenu);
document.addEventListener('keydown', (ev)=>{ if (ev.key === 'Escape') closeMenu(); });

$$('#menuDrawer .drawer-item').forEach(btn => {
  btn.addEventListener('click', ()=>{ if (btn.dataset.view) setViewMode(btn.dataset.view); });
});

// === SDK form wiring (Game code only) ===
(function wireSyncForm(){
  const formEl = document.getElementById('syncForm');
  const gameInput = document.getElementById('syncGame');

  if (!formEl) return;

  formEl.addEventListener('submit', async (ev) => {
    ev.preventDefault();
    const game = (gameInput?.value || '').trim();
    if (!game) { alert('Enter a game code.'); return; }

    // Save just the game code
    remoteSync.config = { game };
    try { saveRemoteConfig(remoteSync.config); } catch {}
    updateRemoteStatus();

    console.log('[sync] connecting to game:', game);
    try {
      await connectRemote();
    } catch (e) {
      console.error('[sync] connect error', e);
      remoteSync.status = 'error';
      remoteSync.lastError = e;
      updateRemoteStatus();
      return;
    }

    // Close the drawer only after we try to connect
    try { closeMenu(); } catch {}
  });

  // Disconnect button
  const disconnectBtn = document.getElementById('syncDisconnect');
  if (disconnectBtn) {
    disconnectBtn.addEventListener('click', () => {
      disconnectRemote();
      remoteSync.config = null;
      try { clearRemoteConfig(); } catch {}
      remoteSync.status = 'idle';
      updateRemoteStatus();
    });
  }
})();


const disconnectBtn = $('#syncDisconnect');
if (disconnectBtn){
  disconnectBtn.addEventListener('click', ()=>{
    disconnectRemote();
    remoteSync.config = null;
    clearRemoteConfig();
    remoteSync.status = 'idle';
    updateRemoteStatus();
    populateSyncForm();
  });
}

console.log('About to render()');
render();

/**********************
 * Init
 **********************/
render();
updateRemoteStatus();
populateSyncForm();
if (remoteConfigured()) connectRemote();

/**********************
 * Self-tests (run with #test)
 **********************/
(function devTests(){
  if (location.hash !== '#test') return; console.group('[Self Tests]');
  try {
    const size = JSON.stringify(serializeState(state)).length; console.log('Persist size (bytes):', size); console.assert(size < 100000, 'payload <100KB');

    // Debounced writes
    let writes = 0; const _setItem = localStorage.setItem.bind(localStorage); localStorage.setItem = (k,v)=>{ if(k===STORAGE_KEY) writes++; _setItem(k,v); };
    for (let i=0;i<20;i++){ state.teams[0].score++; scheduleSave(); }
    setTimeout(()=>{ console.log('Debounced writes (<=5 expected):', writes); localStorage.setItem = _setItem; }, 1200);

    // Timeout -> Start behavior
    startTimeout(0);
    setTimeout(()=>{
      console.assert(state.game.timeoutSecondsRemaining>0, 'timeout should be running');
      toggleStartPause();
      console.assert(state.game.timeoutSecondsRemaining===0, 'timeout cleared on Start');
      console.assert(state.game.running===true, 'game clock should be running after Start');
      pauseClock();

      // Rush affects defense
      state.activeTeam = 0; const beforeDef = state.teams[1].rushes; document.getElementById('g_rushm1').click();
      console.assert(state.teams[1].rushes === Math.max(0, beforeDef-1), 'Rush decrements defending');

      // v9 Girl Play semantics
      state.activeTeam = 0; state.teams[0].girlPlay = 2; state.teams[0].downs = 1; // reset
      document.getElementById('g_guyPlay').click(); // expect 1
      console.assert(state.teams[0].girlPlay === 1, 'Guy Play decrements to 1');
      document.getElementById('g_guyPlay').click(); // expect 0
      console.assert(state.teams[0].girlPlay === 0, 'Guy Play decrements to 0 (Now)');
      document.getElementById('g_guyPlay').click(); // stays 0
      console.assert(state.teams[0].girlPlay === 0, 'Guy Play stays at 0');
      document.getElementById('g_girlPlay').click(); // reset to 2
      console.assert(state.teams[0].girlPlay === 2, 'Girl Play button resets to 2');

      // Halftime resets girl counter to 2
      startHalftime();
      console.assert(state.teams.every(t=> t.girlPlay===2), 'Halftime sets Girl Play In to 2');
      toggleStartPause(); console.assert(state.game.halftimeSecondsRemaining===0, 'halftime cleared on Start'); pauseClock();

      // Editable girl counter (note: direct call relies on implementation; this stays inside try/catch)
      const savedPrompt = window.prompt; window.prompt = ()=> '0';
      try { beginEditValue('girlPlay',0); } catch {}
      window.prompt = savedPrompt;

      console.groupEnd();
    }, 150);
  } catch (e) { console.warn('Self tests error:', e); console.groupEnd(); }
})();
</script>
</body>
</html>