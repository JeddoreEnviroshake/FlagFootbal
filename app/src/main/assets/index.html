<!-- Local HTML template loaded by WebView; replace its contents to customize the app. -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Flag Football Tracker (Touch)</title>
  <style>
    :root {
      --bg: #0f172a; /* slate-900 */
      --card: #ffffff;
      --ink: #0b1120;
      --line: #e2e8f0;
      --accent: #10b981; /* emerald-500 */
      --danger: #ef4444;
      --muted: #64748b;
    }
    html, body { height: 100%; }
    body { margin: 0; overflow-x: hidden; background: var(--bg); color: #e5e7eb; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; transition: background 0.2s ease; }

    body[data-view="player"] {
      background: #020617;
    }

    .topbar {
      position: sticky;
      top: 0;
      z-index: 40;
      background: rgba(15, 23, 42, 0.95);
      border-bottom: 1px solid rgba(148, 163, 184, 0.3);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 16px;
    }

    .menu-toggle {
      border: none;
      background: transparent;
      color: inherit;
      font-size: 22px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      border-radius: 10px;
      cursor: pointer;
    }

    .menu-toggle:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .topbar-title { font-weight: 800; letter-spacing: 0.01em; font-size: 16px; flex: 1; }

    .view-indicator {
      font-size: 13px;
      font-weight: 800;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(148, 163, 184, 0.18);
      color: #e2e8f0;
    }

    .drawer-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.65);
      backdrop-filter: blur(2px);
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s ease;
      z-index: 30;
    }

    .drawer {
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      width: min(360px, 86vw);
      background: #0b1220;
      border-right: 1px solid rgba(148, 163, 184, 0.25);
      transform: translateX(-100%);
      transition: transform 0.2s ease;
      z-index: 40;
      display: flex;
      flex-direction: column;
      padding: 20px 18px 28px;
      gap: 18px;
      overflow-y: auto;
    }

    body.menu-open .drawer { transform: translateX(0); }
    body.menu-open .drawer-backdrop { opacity: 1; visibility: visible; }

    .drawer h2 {
      margin: 0 0 10px;
      font-size: 15px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #cbd5f5;
    }

    .drawer-section { display: flex; flex-direction: column; gap: 10px; }

    .drawer-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      padding: 12px 14px;
      font-weight: 700;
      background: rgba(15, 23, 42, 0.65);
      color: inherit;
      cursor: pointer;
    }

    .drawer-item.active { border-color: var(--accent); background: rgba(16, 185, 129, 0.16); color: #d1fae5; }

    .drawer-note { font-size: 12px; color: #94a3b8; margin: 0; line-height: 1.5; }

    .drawer form { display: flex; flex-direction: column; gap: 10px; }

    .drawer label { font-size: 12px; text-transform: uppercase; letter-spacing: 0.06em; color: #94a3b8; font-weight: 700; }

    .drawer input, .drawer textarea {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(15, 23, 42, 0.6);
      color: #e2e8f0;
      font-size: 14px;
      font-family: inherit;
    }

    .drawer input:focus-visible, .drawer textarea:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }

    .drawer button.save {
      padding: 12px;
      border-radius: 12px;
      border: none;
      font-weight: 800;
      background: var(--accent);
      color: white;
      cursor: pointer;
    }

    .drawer button.secondary {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(15, 23, 42, 0.65);
      color: inherit;
      cursor: pointer;
    }

    .sync-status { font-size: 12px; color: #94a3b8; }

    body.menu-open { overflow: hidden; }

    .app { max-width: 1040px; margin: 0 auto; padding: 16px 12px 32px; display:flex; flex-direction:column; gap:16px; min-height:100vh; }
    h1 { font-size: 20px; margin: 10px 0 6px; font-weight: 800; text-align:center; }

    .layout { display:flex; align-items:flex-start; gap:16px; }
    .primary { flex:1; min-width:0; display:flex; flex-direction:column; gap:12px; }

    /* Clock */
    .clock { display:flex; align-items:center; justify-content:space-between; gap:8px; background:rgba(2,6,23,.7); border:1px solid rgba(148,163,184,.25); border-radius:14px; padding:8px 10px; }
    .clock .left { display:flex; flex-direction:column; gap:4px; }
    .clock .time { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size:26px; font-weight:900; cursor: pointer; }
    .clock-controls { display:flex; gap:6px; flex-wrap: wrap; justify-content:flex-end; }
    .clock-controls .btn { padding:8px 10px; border-radius:12px; border:1px solid rgba(148,163,184,.35); background:#0f172a; color:#e5e7eb; font-weight:800; font-size:14px; }
    .banner { font-size:12px; color:#cbd5e1; font-weight:800; letter-spacing:.02em; }

    /* Teams */
    .teams { display:grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 12px; }

    /* Team card */
    .team { background: var(--card); color: var(--ink); border-radius: 14px; padding: 10px; box-shadow: 0 6px 18px rgba(0,0,0,.18); border: 2px solid var(--line); cursor: pointer; }
    body[data-view="player"] .team { cursor: default; }
    .team.active { border-color: var(--accent); box-shadow: 0 6px 18px rgba(16,185,129,.25); }
    .team header { display:flex; align-items:center; justify-content:center; gap:6px; margin-bottom:10px; }
    .name { font-weight: 900; font-size: 16px; user-select:none; padding:2px 4px; border-radius:6px; }
    body[data-view="player"] .name { cursor: default; }
    .name.editing { background:#f1f5f9; }
    .name-input { font-weight:900; font-size:16px; width:100%; padding:4px 6px; border-radius:8px; border:2px solid var(--line); text-align:center; }

    .stats { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .stat { background:#f8fafc; border:1px solid var(--line); border-radius:10px; padding:10px; display:flex; flex-direction:column; align-items:center; gap:6px; text-align:center; }
    .stat.full { grid-column: 1 / -1; }
    .stat label { display:block; font-size:11px; color:#334155; font-weight:700; text-transform:uppercase; letter-spacing:.04em; }

    /* Inline numeric editor (kept from codex/refactor-inline-editor...) */
    .val { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 22px; font-weight: 900; cursor:pointer; text-align:center; }
    body[data-view="player"] .val { cursor: default; }
    .val.editing { cursor:text; background:#e2e8f0; border-radius:8px; padding:8px; display:flex; flex-direction:column; gap:6px; box-shadow: inset 0 0 0 1px rgba(148,163,184,.4); }
    .val-input { width:100%; padding:12px 10px; border-radius:8px; border:2px solid var(--line); font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size:20px; font-weight:900; text-align:center; color:var(--ink); background:#ffffff; -webkit-appearance: none; }
    .val-input:focus { outline:none; border-color: var(--accent); box-shadow:0 0 0 3px rgba(16,185,129,.2); }
    .val-input.invalid { border-color: var(--danger); box-shadow:0 0 0 3px rgba(239,68,68,.2); }
    .val-error { font-size:11px; color: var(--danger); font-weight:700; min-height:14px; text-align:center; visibility:hidden; }
    .val-error.visible { visibility:visible; }

    /* Global control card */
    .controls-card { position:sticky; top:120px; width: min(280px, 45vw); align-self:stretch; flex-shrink:0; }
    .controls { background:#0b1220; border:1px solid rgba(148,163,184,.35); border-radius:14px; padding:12px; display:flex; flex-direction:column; gap:10px; max-height: calc(100vh - 160px); overflow:auto; }
    .controls .label { font-size:12px; color:#94a3b8; font-weight:800; text-transform:uppercase; letter-spacing:.04em; margin-bottom:6px; }
    .controls .row3 { display:grid; grid-template-columns:repeat(3, 1fr); gap:8px; }
    .controls .row2 { display:grid; grid-template-columns:repeat(2, 1fr); gap:8px; }
    .controls .row1 { display:grid; grid-template-columns:1fr; gap:8px; }
    .btn { -webkit-tap-highlight-color: transparent; display:inline-flex; align-items:center; justify-content:center; text-align:center; width:100%; padding:12px 10px; border-radius:12px; border:2px solid var(--line); font-weight:900; font-size:15px; background:#ffffff; }
    .btn.tall { padding-top: 24px; padding-bottom: 24px; }
    .btn:active { transform: scale(0.98); }
    .btn.primary { background: var(--accent); border-color: var(--accent); color:white; }
    .btn.warn { background:#fee2e2; color:#7f1d1d; border-color:#fecaca; }

    button:disabled { opacity: 0.45; cursor: not-allowed; }

    .muted { color: var(--muted); font-size:12px; }

    @media (max-width: 860px) {
      .layout { flex-direction:column; }
      .controls-card { position:static; width:100%; }
      .controls { flex-direction:column; max-height:none; overflow:visible; }
      .teams { grid-template-columns:repeat(auto-fit, minmax(160px, 1fr)); }
    }
  </style>
</head>
<body>
  <header class="topbar">
    <button class="menu-toggle" id="menuToggle" aria-label="Open menu" aria-expanded="false">â˜°</button>
    <div class="topbar-title">Flag Football Game Tracker</div>
    <div class="view-indicator" id="viewIndicator">Ref View</div>
  </header>

  <nav class="drawer" id="menuDrawer" aria-hidden="true">
    <div class="drawer-section">
      <h2>View</h2>
      <button class="drawer-item" data-view="ref" type="button">Ref view</button>
      <button class="drawer-item" data-view="player" type="button">Player view</button>
      <p class="drawer-note">Refs can update the score, clock, and stats. Players and spectators see a read-only dashboard.</p>
    </div>

    <div class="drawer-section">
      <h2>Live sync</h2>
      <form id="syncForm">
        <label for="syncUrl">Firebase database URL</label>
        <input id="syncUrl" name="url" type="url" placeholder="https://your-project-default-rtdb.firebaseio.com" />

        <label for="syncAuth">Database secret (optional)</label>
        <input id="syncAuth" name="auth" type="text" placeholder="Only needed for locked rules" />

        <label for="syncGame">Game code</label>
        <input id="syncGame" name="game" type="text" placeholder="e.g. week1-field1" />

        <button class="save" type="submit">Save &amp; connect</button>
      </form>
      <button class="secondary" type="button" id="syncDisconnect">Disconnect</button>
      <p class="drawer-note">Create a free Firebase Realtime Database, set rules to public or use a database secret, then share the game code with refs and viewers.</p>
      <div class="sync-status" id="syncStatus" role="status">Offline</div>
    </div>
  </nav>
  <div class="drawer-backdrop" id="menuBackdrop" tabindex="-1" aria-hidden="true"></div>

  <div class="app">
    <h1>Flag Football Game Tracker</h1>

    <div class="layout">
      <div class="primary">
        <!-- Game Clock -->
        <div class="clock">
          <div class="left">
            <div class="muted">Game Clock</div>
            <div class="banner" id="timeoutBanner" style="display:none;">Timeout â€” <span id="timeoutTeam"></span> <span id="timeoutTime">1:00</span></div>
            <div class="banner" id="halftimeBanner" style="display:none;">Halftime â€” <span id="halftimeTime">2:00</span></div>
          </div>
          <div class="time" id="gameTime" title="Tap to edit when paused">15:00</div>
          <div class="clock-controls">
            <button class="btn" id="clockStartPause" data-role="ref-only">Start</button>
            <button class="btn" id="timeoutHome" data-role="ref-only">Timeout (Home)</button>
            <button class="btn" id="timeoutAway" data-role="ref-only">Timeout (Away)</button>
            <button class="btn" id="halftimeBtn" data-role="ref-only">Halftime</button>
          </div>
        </div>

        <!-- Teams -->
        <section class="teams" id="teams"></section>
      </div>

      <!-- Global Controls (shared by both teams) -->
      <aside class="controls-card">
        <div class="controls">
          <div class="label">Active team: <span id="activeTeamLabel">Home</span> â€” tap a team card to switch</div>
          <div class="row3">
            <button class="btn primary" id="g_score6" data-role="ref-only">+6</button>
            <button class="btn" id="g_score1" data-role="ref-only">+1</button>
            <button class="btn warn" id="g_scorem1" data-role="ref-only">-1</button>
          </div>
          <!-- Reordered: First Down, Guy Play, Rush, Girl Play -->
          <div class="row2">
            <button class="btn tall" id="g_downReset" data-role="ref-only">First Down</button>
            <button class="btn tall" id="g_guyPlay" data-role="ref-only">Guy Play</button>
          </div>
          <div class="row2">
            <button class="btn tall" id="g_rushm1" data-role="ref-only">Rush</button>
            <button class="btn tall" id="g_girlPlay" data-role="ref-only">Girl Play</button>
          </div>
          <div class="row1">
            <button class="btn tall warn" id="g_turnover" data-role="ref-only">Turnover</button>
          </div>
        </div>
      </aside>
    </div>
  </div>

<script>
/**********************
 * Storage & Migration
 **********************/
const STORAGE_KEY = 'flag_football_touch_v9';
const LEGACY_KEYS = ['flag_football_touch_v8','flag_football_touch_v7','flag_football_touch_v6','flag_football_touch_v5','flag_football_touch_v4'];
const VIEW_MODE_KEY = 'flag_football_touch_view_mode';
const REMOTE_CONFIG_KEY = 'flag_football_touch_remote_v1';

// NOTE: As of v9, girlPlay now represents "plays until required girl play" on a 0-2 scale
// 2 -> "2", 1 -> "1", 0 -> "Now". Previously (v8 and earlier) girlPlay was 1..3 rolling counter.

function serializeState(s){
  const teamSource = Array.isArray(s.teams) && s.teams.length ? s.teams : defaultState().teams;
  const game = s.game || {};
  const safe = {
    activeTeam: Math.max(0, Math.min(1, s.activeTeam != null ? s.activeTeam : 0)),
    teams: teamSource.map(t => ({
      name: t.name,
      score: t.score|0,
      downs: Math.min(4, Math.max(1, t.downs|0)) || 1,
      girlPlay: Math.min(2, Math.max(0, t.girlPlay|0)), // clamp to 0..2
      rushes: Math.max(0, t.rushes|0),
      timeouts: Math.max(0, t.timeouts|0)
    })),
    game: {
      seconds: Math.max(0, game.seconds|0) || 15*60,
      running: !!game.running,
      timeoutSecondsRemaining: Math.max(0, game.timeoutSecondsRemaining|0),
      timeoutTeam: game.timeoutTeam == null ? null : game.timeoutTeam,
      halftimeSecondsRemaining: Math.max(0, game.halftimeSecondsRemaining|0)
    }
  };
  if (safe.game.timeoutTeam != null) {
    safe.game.timeoutTeam = Math.max(0, Math.min(1, safe.game.timeoutTeam|0));
  } else {
    safe.game.timeoutTeam = null;
  }
  return safe;
}

function safeSave(){
  const payload = JSON.stringify(serializeState(state));
  try { localStorage.setItem(STORAGE_KEY, payload); }
  catch(e){
    try {
      const tiny = JSON.stringify({
        a: state.activeTeam,
        t: state.teams.map(t=>({n:t.name, s:t.score|0, d:t.downs|0, g:Math.min(2,Math.max(0,t.girlPlay|0)), r:t.rushes|0, o:t.timeouts|0})),
        g: {s: state.game.seconds|0}
      });
      localStorage.setItem(STORAGE_KEY, tiny);
    } catch(e2){ try{ localStorage.removeItem(STORAGE_KEY);}catch{} }
  }
}
let saveTimer=null; function scheduleSave(){ clearTimeout(saveTimer); saveTimer = setTimeout(safeSave, 400); }

function requestPersist(){
  scheduleSave();
  scheduleRemotePush();
}

function renderAndPersist(){
  render();
  requestPersist();
}

/**********************
 * App State
 **********************/
const $ = (sel) => document.querySelector(sel);
const $$ = (sel) => Array.from(document.querySelectorAll(sel));

const defaultState = () => ({
  activeTeam: 0,
  teams: [
    { name: 'Home', score: 0, downs: 1, girlPlay: 2, rushes: 2, timeouts: 3 }, // start at 2 plays until girl
    { name: 'Away', score: 0, downs: 1, girlPlay: 2, rushes: 2, timeouts: 3 }
  ],
  game: { seconds: 15*60, running: false, timeoutSecondsRemaining: 0, timeoutTeam: null, halftimeSecondsRemaining: 0 }
});

const VALUE_RULES = {
  score: { label: 'Score', min: 0, minMessage: 'Score must be 0 or higher', hint: 'Enter 0 or higher' },
  downs: { label: 'Down', min: 1, max: 4, minMessage: 'Down must be between 1 and 4', maxMessage: 'Down must be between 1 and 4', hint: 'Use values from 1-4' },
  girlPlay: { label: 'Girl Play In', min: 0, max: 2, minMessage: 'Girl Play In must be between 0 and 2', maxMessage: 'Girl Play In must be between 0 and 2', hint: '0 = Now, 2 = Two plays' },
  rushes: { label: 'Rushes', min: 0, minMessage: 'Rushes must be 0 or higher', hint: 'Enter 0 or higher' },
  timeouts: { label: 'Timeouts', min: 0, minMessage: 'Timeouts must be 0 or higher', hint: 'Enter 0 or higher' }
};

function migrateGirlPlay(oldVal){
  // v8 style (1..3 rolling) -> v9 remaining (2..0)
  // Map: 1 -> 2, 2 -> 1, 3 -> 0
  if (typeof oldVal !== 'number') return 2;
  if (oldVal <= 1) return 2;
  if (oldVal === 2) return 1;
  return 0; // 3 or higher
}

function inflate(obj){
  const base = defaultState(); if (!obj) return base;
  try {
    const activeTeamRaw = obj.activeTeam != null ? obj.activeTeam : (obj.a != null ? obj.a : 0);
    const fallbackTeams = base.teams;
    const teamsSource = Array.isArray(obj.teams) && obj.teams.length
      ? obj.teams
      : (Array.isArray(obj.t) && obj.t.length ? obj.t : fallbackTeams);
    base.teams = teamsSource.map((t,i)=>{
      const prev = fallbackTeams[i] || {};
      // Accept both schemas for girlPlay
      const gp = (t.girlPlay == null) ? prev.girlPlay : t.girlPlay;
      const girlV9 = (gp>=0 && gp<=2) ? gp : migrateGirlPlay(gp);
      return {
        name: t.name != null ? t.name : (t.n != null ? t.n : (prev.name != null ? prev.name : 'Team')),
        score: t.score != null ? t.score : (t.s != null ? t.s : 0),
        downs: t.downs != null ? t.downs : (t.d != null ? t.d : 1),
        girlPlay: girlV9,
        rushes: t.rushes != null ? t.rushes : (t.r != null ? t.r : 2),
        timeouts: t.timeouts != null ? t.timeouts : (t.o != null ? t.o : 3)
      };
    });
    const teamsLength = base.teams.length || fallbackTeams.length;
    const activeTeamNum = Number(activeTeamRaw);
    const normalizedActiveTeam = Number.isFinite(activeTeamNum)
      ? Math.max(0, Math.min(teamsLength > 0 ? teamsLength - 1 : 0, Math.floor(activeTeamNum)))
      : 0;
    base.activeTeam = normalizedActiveTeam;
    const g = obj.game != null ? obj.game : (obj.g != null ? obj.g : {});
    const secondsSource = g.seconds != null ? g.seconds : (g.s != null ? g.s : 15*60);
    base.game.seconds = Math.max(0, secondsSource);
    base.game.running = !!g.running;
    const timeoutSeconds = g.timeoutSecondsRemaining != null ? g.timeoutSecondsRemaining : (g.tr != null ? g.tr : 0);
    base.game.timeoutSecondsRemaining = Math.max(0, timeoutSeconds);
    if (g.timeoutTeam == null) base.game.timeoutTeam = null;
    else base.game.timeoutTeam = Math.max(0, Math.min(1, g.timeoutTeam|0));
    const halftimeSeconds = g.halftimeSecondsRemaining != null ? g.halftimeSecondsRemaining : (g.hr != null ? g.hr : 0);
    base.game.halftimeSecondsRemaining = Math.max(0, halftimeSeconds);
  } catch {}
  return base;
}

function loadMigrated(){
  try { const raw = localStorage.getItem(STORAGE_KEY); if (raw) return inflate(JSON.parse(raw)); } catch {}
  for (const k of LEGACY_KEYS){
    try {
      const raw = localStorage.getItem(k); if (!raw) continue;
      const migrated = inflate(JSON.parse(raw));
      localStorage.setItem(STORAGE_KEY, JSON.stringify(serializeState(migrated)));
      try { localStorage.removeItem(k); } catch {}
      return migrated;
    } catch {}
  }
  return null;
}

function loadViewMode(){
  try {
    const raw = localStorage.getItem(VIEW_MODE_KEY);
    if (raw === 'ref' || raw === 'player') return raw;
  } catch {}
  return 'ref';
}

function saveViewMode(mode){
  try { localStorage.setItem(VIEW_MODE_KEY, mode); } catch {}
}

function loadRemoteConfig(){
  try {
    const raw = localStorage.getItem(REMOTE_CONFIG_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== 'object') return null;
    if (!parsed.url || !parsed.game) return null;
    return {
      url: parsed.url,
      auth: parsed.auth || '',
      game: parsed.game,
      lastKnown: parsed.lastKnown || null
    };
  } catch {}
  return null;
}

function saveRemoteConfig(cfg){
  try { localStorage.setItem(REMOTE_CONFIG_KEY, JSON.stringify(cfg)); } catch {}
}

function clearRemoteConfig(){
  try { localStorage.removeItem(REMOTE_CONFIG_KEY); } catch {}
}

let state = loadMigrated() || defaultState();
let timeoutTimer = null; // 1:00 timeout
let halftimeTimer = null; // 2:00 halftime
let clockTimer = null;    // game clock
let activeValueEditor = null;
let viewMode = loadViewMode();

const remoteSync = {
  config: loadRemoteConfig(),
  source: null,
  status: 'idle',
  lastError: null,
  pushTimer: null,
  lastPushedAt: 0,
  applying: false,
  connected: false,
  pushing: false,
  pendingPush: false
};

/**********************
 * Rendering
 **********************/
function fmt(sec){ const m=Math.floor(sec/60); const s=sec%60; const padded = ('0' + s).slice(-2); return `${m}:${padded}`; }
function fmtGirl(val){ return val===0 ? 'Now' : String(val); }

function render(){
  document.body.dataset.view = viewMode;
  const indicator = $('#viewIndicator');
  if (indicator) indicator.textContent = viewMode === 'ref' ? 'Ref View' : 'Player View';
  $$('#menuDrawer .drawer-item').forEach(btn => btn.classList.toggle('active', btn.dataset.view === viewMode));
  const isRef = viewMode === 'ref';
  $$('button[data-role="ref-only"]').forEach(btn => { btn.disabled = !isRef; });

  // Clock & banners
  $('#gameTime').textContent = fmt(state.game.seconds);
  if (state.game.timeoutSecondsRemaining>0){
    $('#timeoutBanner').style.display='';
    const timeoutTeamIndex = state.game.timeoutTeam;
    let timeoutName = '';
    if (timeoutTeamIndex != null && state.teams[timeoutTeamIndex]) {
      timeoutName = state.teams[timeoutTeamIndex].name;
    }
    $('#timeoutTeam').textContent = timeoutName;
    $('#timeoutTime').textContent = fmt(state.game.timeoutSecondsRemaining);
  } else { $('#timeoutBanner').style.display='none'; }
  if (state.game.halftimeSecondsRemaining>0){
    $('#halftimeBanner').style.display='';
    $('#halftimeTime').textContent = fmt(state.game.halftimeSecondsRemaining);
  } else { $('#halftimeBanner').style.display='none'; }

  $('#clockStartPause').textContent = state.game.running ? 'Pause' : 'Start';
  const activeTeam = state.teams[state.activeTeam] || state.teams[0];
  const activeTeamLabel = $('#activeTeamLabel');
  if (activeTeamLabel && activeTeam) {
    activeTeamLabel.textContent = activeTeam.name;
  }
  renderTeams();
}

function renderTeams(){
  const editingVal = document.querySelector('.val.editing');
  let restoreEdit = null;
  if (editingVal) {
    const { team, kind } = editingVal.dataset;
    const input = editingVal.querySelector('input');
    if (team != null && kind && input) {
      restoreEdit = {
        team: Number(team),
        kind,
        value: input.value,
        selectionStart: input.selectionStart != null ? input.selectionStart : input.value.length,
        selectionEnd: input.selectionEnd != null ? input.selectionEnd : input.value.length
      };
    }
  }

  const editingEnabled = viewMode === 'ref';
  if (!editingEnabled && activeValueEditor) {
    try { activeValueEditor(false); } catch {}
  }
  activeValueEditor = null;
  const host = $('#teams'); host.innerHTML = '';
  state.teams.forEach((t, idx) => {
    const sec = document.createElement('section'); sec.className = 'team' + (state.activeTeam===idx?' active':'');
    if (editingEnabled){
      sec.addEventListener('click', ()=>{ state.activeTeam = idx; renderAndPersist(); });
    }

    const header = document.createElement('header');
    const nameSpan = document.createElement('span'); nameSpan.className = 'name'; nameSpan.textContent = t.name;
    if (editingEnabled){
      nameSpan.addEventListener('click', (ev)=>{ ev.stopPropagation(); beginEditName(idx, nameSpan); });
    }
    header.appendChild(nameSpan);

    const stats = document.createElement('div'); stats.className = 'stats';
    const score = document.createElement('div'); score.className = 'stat full'; score.innerHTML = `<label>Score</label><div class="val" data-kind="score" data-team="${idx}">${t.score}</div>`;
    const down = document.createElement('div'); down.className='stat'; down.innerHTML = `<label>Down</label><div class="val" data-kind="downs" data-team="${idx}">${t.downs}</div>`;
    const girl = document.createElement('div'); girl.className='stat'; girl.innerHTML = `<label>Girl Play In</label><div class="val" data-kind="girlPlay" data-team="${idx}">${fmtGirl(t.girlPlay)}</div>`;
    const rush = document.createElement('div'); rush.className='stat'; rush.innerHTML = `<label>Rushes</label><div class="val" data-kind="rushes" data-team="${idx}">${t.rushes}</div>`;
    const to = document.createElement('div'); to.className='stat'; to.innerHTML = `<label>Timeouts</label><div class="val" data-kind="timeouts" data-team="${idx}">${t.timeouts}</div>`;

    [score,down,girl,rush,to].forEach(el=>stats.appendChild(el));

    sec.appendChild(header); sec.appendChild(stats); host.appendChild(sec);
  });

  if (editingEnabled){
    $$('#teams .val').forEach(v => {
      v.addEventListener('click', (ev)=>{ ev.stopPropagation(); beginEditValue(v, v.dataset.kind, +v.dataset.team); });
    });
  }

  if (restoreEdit && editingEnabled) {
    const valEl = host.querySelector(`.val[data-team="${restoreEdit.team}"][data-kind="${restoreEdit.kind}"]`);
    if (valEl) {
      beginEditValue(valEl, restoreEdit.kind, restoreEdit.team, { skipCancelExisting: true, restore: restoreEdit });
    }
  }
}

/**********************
 * Remote Sync (Firebase Realtime Database)
 **********************/
function remoteConfigured(){
  return !!(remoteSync.config && remoteSync.config.url && remoteSync.config.game);
}

function remoteUrl(params = {}){
  if (!remoteConfigured()) return null;
  let base = remoteSync.config.url.trim();
  base = base.replace(/\.json$/i, '');
  base = base.replace(/\/+$, '');
  const key = encodeURIComponent(remoteSync.config.game);
  const pairs = [];
  if (remoteSync.config.auth) pairs.push(['auth', remoteSync.config.auth]);
  for (const [k,v] of Object.entries(params)){
    if (v == null || v === '') continue;
    pairs.push([k, v]);
  }
  const query = pairs.length ? '?' + pairs.map(([k,v])=>`${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join('&') : '';
  return `${base}/games/${key}.json${query}`;
}

function disconnectRemote(){
  if (remoteSync.source){
    try { remoteSync.source.close(); } catch {}
  }
  remoteSync.source = null;
  remoteSync.connected = false;
  if (remoteSync.pushTimer){ clearTimeout(remoteSync.pushTimer); remoteSync.pushTimer = null; }
  remoteSync.pendingPush = false;
}

function updateRemoteStatus(){
  const el = $('#syncStatus');
  if (!el) return;
  if (!remoteConfigured()){
    el.textContent = 'Offline';
    return;
  }
  if (remoteSync.status === 'connecting') el.textContent = `Connecting to ${remoteSync.config.game}â€¦`;
  else if (remoteSync.status === 'connected') el.textContent = `Connected â€¢ ${remoteSync.config.game}`;
  else if (remoteSync.status === 'error') {
    const lastError = remoteSync.lastError;
    const message = lastError && lastError.message ? lastError.message : '';
    const msg = message.indexOf('EventSource') !== -1
      ? 'Live sync needs a modern browser (EventSource unsupported).'
      : 'Sync error â€” check URL or credentials';
    el.textContent = msg;
  }
  else el.textContent = 'Ready to connect';
}

function populateSyncForm(){
  const form = $('#syncForm'); if (!form) return;
  const cfg = remoteSync.config || {};
  form.url.value = cfg.url || '';
  form.auth.value = cfg.auth || '';
  form.game.value = cfg.game || '';
}

function scheduleRemotePush(){
  if (!remoteConfigured() || viewMode !== 'ref' || remoteSync.applying) return;
  if (remoteSync.pushing){
    remoteSync.pendingPush = true;
    return;
  }
  if (remoteSync.pushTimer) clearTimeout(remoteSync.pushTimer);
  remoteSync.pushTimer = setTimeout(pushRemoteNow, 250);
}

async function pushRemoteNow(){
  if (!remoteConfigured() || remoteSync.pushing) return;
  const url = remoteUrl(); if (!url) return;
  const payload = { version: 1, updatedAt: Date.now(), state: serializeState(state) };
  remoteSync.pushing = true;
  remoteSync.lastPushedAt = payload.updatedAt;
  try {
    const res = await fetch(url, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    remoteSync.status = 'connected';
    remoteSync.connected = true;
    remoteSync.lastError = null;
  } catch (err) {
    remoteSync.status = 'error';
    remoteSync.lastError = err;
  } finally {
    remoteSync.pushing = false;
    if (remoteSync.pendingPush){
      remoteSync.pendingPush = false;
      scheduleRemotePush();
    }
    updateRemoteStatus();
  }
}

function syncLocalTimersWithState(){
  if (!state.game.running && clockTimer){ clearInterval(clockTimer); clockTimer = null; }
  if (state.game.timeoutSecondsRemaining <= 0 && timeoutTimer){ clearInterval(timeoutTimer); timeoutTimer = null; }
  if (state.game.halftimeSecondsRemaining <= 0 && halftimeTimer){ clearInterval(halftimeTimer); halftimeTimer = null; }
}

function applySerializedState(serialized, { fromRemote = false } = {}){
  const next = inflate(serialized);
  state = next;
  syncLocalTimersWithState();
  if (fromRemote){
    render();
    scheduleSave();
  } else {
    renderAndPersist();
  }
}

function handleRemotePayload(raw){
  if (!raw) return;
  const body = raw && raw.state != null ? raw.state : raw;
  if (!body) return;
  const updatedAt = raw && raw.updatedAt != null ? raw.updatedAt : null;
  if (updatedAt && updatedAt === remoteSync.lastPushedAt) return;
  remoteSync.applying = true;
  try {
    applySerializedState(body, { fromRemote: true });
  } finally {
    remoteSync.applying = false;
  }
}

function connectRemote(){
  disconnectRemote();
  if (!remoteConfigured()){
    remoteSync.status = 'idle';
    updateRemoteStatus();
    return;
  }
  remoteSync.status = 'connecting';
  updateRemoteStatus();
  const initUrl = remoteUrl();
  if (initUrl){
    fetch(initUrl)
      .then(res => res.ok ? res.json() : null)
      .then(data => {
        if (!data) {
          if (viewMode === 'ref') scheduleRemotePush();
          return;
        }
        handleRemotePayload(data);
      })
      .catch(err => {
        remoteSync.status = 'error';
        remoteSync.lastError = err;
        updateRemoteStatus();
      });
  }
  if (typeof EventSource === 'undefined'){
    remoteSync.status = 'error';
    remoteSync.lastError = new Error('EventSource is not supported in this browser');
    updateRemoteStatus();
    return;
  }
  const streamUrl = remoteUrl({ print: 'silent' });
  if (!streamUrl) return;
  try {
    const source = new EventSource(streamUrl);
    remoteSync.source = source;
    source.onopen = () => {
      remoteSync.connected = true;
      remoteSync.status = 'connected';
      updateRemoteStatus();
    };
    source.onerror = () => {
      remoteSync.connected = false;
      if (remoteSync.status !== 'error'){
        remoteSync.status = 'error';
        updateRemoteStatus();
      }
    };
    const handler = (event) => {
      try {
        const payload = JSON.parse(event.data);
        if (!payload) return;
        if (payload.data == null) return;
        handleRemotePayload(payload.data);
      } catch (err) {
        console.warn('Remote sync parse error', err);
      }
    };
    source.addEventListener('put', handler);
    source.addEventListener('patch', handler);
    source.onmessage = handler;
  } catch (err) {
    remoteSync.status = 'error';
    remoteSync.lastError = err;
    updateRemoteStatus();
  }
}

function beginEditName(idx, spanEl){
  if (viewMode !== 'ref') return;
  if (spanEl.classList.contains('editing')) return;
  spanEl.classList.add('editing');
  const input = document.createElement('input'); input.className = 'name-input'; input.value = state.teams[idx].name;
  spanEl.replaceWith(input); input.focus(); input.setSelectionRange(0, input.value.length);
  const finish = (commit) => {
    const newSpan = document.createElement('span'); newSpan.className = 'name';
    if (commit) state.teams[idx].name = input.value.trim() || state.teams[idx].name;
    newSpan.textContent = state.teams[idx].name;
    newSpan.addEventListener('click', (ev)=>{ ev.stopPropagation(); beginEditName(idx, newSpan); });
    input.replaceWith(newSpan);
    if (commit) renderAndPersist(); else render();
  };
  input.addEventListener('blur', () => finish(true));
  input.addEventListener('keydown', (e)=>{ if(e.key==='Enter') finish(true); if(e.key==='Escape') finish(false); });
}

function beginEditValue(valEl, kind, teamIdx, opts = {}){
  if (viewMode !== 'ref') return;
  if (!valEl || valEl.classList.contains('editing')) return;
  const team = state.teams[teamIdx];
  const rules = VALUE_RULES[kind];
  if (!team || !rules) return;

  if (activeValueEditor && !opts.skipCancelExisting) activeValueEditor(false);

  const originalData = team[kind] != null ? team[kind] : '';
  const originalDisplay = kind==='girlPlay' ? fmtGirl(team.girlPlay) : String(originalData);
  const originalValue = String(originalData);
  let startingValue = originalValue;
  if (opts.restore && Object.prototype.hasOwnProperty.call(opts.restore, 'value')) {
    startingValue = opts.restore.value;
  }

  valEl.classList.add('editing');
  valEl.textContent = '';

  const input = document.createElement('input');
  input.className = 'val-input';
  input.type = 'text';
  input.inputMode = 'numeric';
  input.pattern = '[0-9]*';
  input.autocomplete = 'off';
  input.spellcheck = false;
  input.value = startingValue;
  input.setAttribute('aria-label', `${rules.label} for ${team.name}`);
  valEl.appendChild(input);

  const errorId = `val-error-${teamIdx}-${kind}`;
  input.setAttribute('aria-describedby', errorId);
  const error = document.createElement('div');
  error.className = 'val-error';
  error.id = errorId;
  error.setAttribute('role','alert');
  error.setAttribute('aria-live','polite');
  valEl.appendChild(error);

  const focusInput = () => {
    input.focus();
    if (opts.restore && opts.restore.selectionStart != null) {
      const restoreStart = opts.restore.selectionStart;
      const restoreEnd = opts.restore.selectionEnd != null ? opts.restore.selectionEnd : restoreStart;
      try { input.setSelectionRange(restoreStart, restoreEnd); }
      catch {}
    } else if (typeof input.select === 'function') {
      input.select();
    }
  };
  const showError = (msg) => {
    error.textContent = msg || '';
    error.classList.toggle('visible', !!msg);
    input.classList.toggle('invalid', !!msg);
  };

  let closed = false;
  const finish = (commit) => {
    if (closed) return;
    if (!commit){
      closed = true;
      activeValueEditor = null;
      showError('');
      valEl.classList.remove('editing');
      valEl.textContent = originalDisplay;
      return;
    }

    const raw = input.value.trim();
    if (!raw){ showError('Enter a number'); focusInput(); return; }
    if (!/^-?\d+$/.test(raw)){ showError('Use whole numbers only'); focusInput(); return; }
    const nextVal = parseInt(raw, 10);
    if (Number.isNaN(nextVal)){ showError('Enter a number'); focusInput(); return; }
    if (rules.min != null && nextVal < rules.min){ showError(rules.minMessage || `${rules.label} must be â‰¥ ${rules.min}`); focusInput(); return; }
    if (rules.max != null && nextVal > rules.max){ showError(rules.maxMessage || `${rules.label} must be â‰¤ ${rules.max}`); focusInput(); return; }

    closed = true;
    activeValueEditor = null;
    showError('');
    team[kind] = nextVal;
    valEl.classList.remove('editing');
    valEl.textContent = kind==='girlPlay' ? fmtGirl(nextVal) : String(nextVal);
    renderAndPersist();
  };

  activeValueEditor = finish;

  input.addEventListener('click', (e)=>e.stopPropagation());
  input.addEventListener('keydown', (e)=>{
    if (e.key === 'Enter'){ e.preventDefault(); finish(true); }
    else if (e.key === 'Escape'){ e.preventDefault(); finish(false); }
  });
  input.addEventListener('blur', ()=>{
    setTimeout(()=>{
      if (!valEl.isConnected) return;
      const active = document.activeElement;
      if (!valEl.contains(active)) finish(true);
    }, 20);
  });
  input.addEventListener('input', ()=>{ if (error.textContent) showError(''); });

  setTimeout(()=>{ focusInput(); }, 0);
}

/**********************
 * Global Controls
 **********************/
$('#g_score6').addEventListener('click', ()=>{
  if (viewMode !== 'ref') return;
  state.teams[state.activeTeam].score += 6;
  renderAndPersist();
});
$('#g_score1').addEventListener('click', ()=>{
  if (viewMode !== 'ref') return;
  state.teams[state.activeTeam].score += 1;
  renderAndPersist();
});
$('#g_scorem1').addEventListener('click', ()=>{
  if (viewMode !== 'ref') return;
  state.teams[state.activeTeam].score = Math.max(0, state.teams[state.activeTeam].score - 1);
  renderAndPersist();
});

// Guy/Girl play (v9 semantics)
$('#g_guyPlay').addEventListener('click', ()=>{
  if (viewMode !== 'ref') return;
  const t = state.teams[state.activeTeam];
  // +1 Down, decrement Girl Play In until 0 (Now), then stick at 0
  t.downs = t.downs >= 4 ? 1 : t.downs + 1;
  t.girlPlay = Math.max(0, (t.girlPlay|0) - 1);
  renderAndPersist();
});
$('#g_girlPlay').addEventListener('click', ()=>{
  if (viewMode !== 'ref') return;
  const t = state.teams[state.activeTeam];
  // Girl Play happens: reset counter to 2 and +1 Down
  t.girlPlay = 2;
  t.downs = t.downs >= 4 ? 1 : t.downs + 1;
  renderAndPersist();
});

// First Down
$('#g_downReset').addEventListener('click', ()=>{
  if (viewMode !== 'ref') return;
  state.teams[state.activeTeam].downs = 1;
  renderAndPersist();
});

// Turnover
$('#g_turnover').addEventListener('click', ()=>{
  if (viewMode !== 'ref') return;
  const currentTeam = state.teams[state.activeTeam];
  currentTeam.downs = 1;
  currentTeam.girlPlay = 2;
  state.activeTeam = state.activeTeam === 0 ? 1 : 0;
  renderAndPersist();
});

// Rush (defense)
$('#g_rushm1').addEventListener('click', ()=>{
  if (viewMode !== 'ref') return;
  const def = state.activeTeam===0?1:0;
  state.teams[def].rushes = Math.max(0, state.teams[def].rushes - 1);
  renderAndPersist();
});

/**********************
 * Clock, Timeout & Halftime
 **********************/
function clearTimeoutMode(){
  if (timeoutTimer){ clearInterval(timeoutTimer); timeoutTimer=null; }
  state.game.timeoutSecondsRemaining=0;
  state.game.timeoutTeam=null;
}
function clearHalftimeMode(){
  if (halftimeTimer){ clearInterval(halftimeTimer); halftimeTimer=null; }
  state.game.halftimeSecondsRemaining=0;
}

function startClock(){
  if (viewMode !== 'ref') return;
  if (state.game.timeoutSecondsRemaining>0) clearTimeoutMode();
  if (state.game.halftimeSecondsRemaining>0) clearHalftimeMode();
  if (clockTimer) return;
  state.game.running = true;
  renderAndPersist();
  clockTimer = setInterval(()=>{
    if (state.game.seconds>0){
      state.game.seconds--;
      renderAndPersist();
    } else {
      pauseClock();
    }
  }, 1000);
}
function pauseClock(){
  state.game.running=false;
  if (clockTimer){ clearInterval(clockTimer); clockTimer=null; }
  renderAndPersist();
}
function toggleStartPause(){
  if (viewMode !== 'ref') return;
  state.game.running ? pauseClock() : startClock();
}

function startTimeout(teamIdx){
  if (viewMode !== 'ref') return;
  if (timeoutTimer || state.game.timeoutSecondsRemaining>0) return;
  const t = state.teams[teamIdx]; if (t.timeouts<=0) return;
  t.timeouts--; pauseClock(); clearHalftimeMode();
  state.game.timeoutSecondsRemaining = 60; state.game.timeoutTeam = teamIdx;
  timeoutTimer = setInterval(()=>{
    if (state.game.timeoutSecondsRemaining>0){
      state.game.timeoutSecondsRemaining--;
      renderAndPersist();
    }
    else {
      clearTimeoutMode();
      renderAndPersist();
    }
  },1000);
  renderAndPersist();
}

function startHalftime(){
  if (viewMode !== 'ref') return;
  pauseClock(); clearTimeoutMode();
  state.teams.forEach(t=>{ t.downs=1; t.girlPlay=2; t.rushes=2; t.timeouts=3; });
  state.game.seconds = 15*60;
  state.game.halftimeSecondsRemaining = 120;
  if (halftimeTimer) clearInterval(halftimeTimer);
  halftimeTimer = setInterval(()=>{
    if (state.game.halftimeSecondsRemaining>0){
      state.game.halftimeSecondsRemaining--;
      renderAndPersist();
    }
    else {
      clearHalftimeMode();
      renderAndPersist();
    }
  }, 1000);
  renderAndPersist();
}

$('#clockStartPause').addEventListener('click', toggleStartPause);
$('#timeoutHome').addEventListener('click', ()=> startTimeout(0));
$('#timeoutAway').addEventListener('click', ()=> startTimeout(1));
$('#halftimeBtn').addEventListener('click', startHalftime);

// Edit time when paused
$('#gameTime').addEventListener('click', ()=>{
  if (viewMode !== 'ref') return;
  if (state.game.running || state.game.timeoutSecondsRemaining>0 || state.game.halftimeSecondsRemaining>0) return;
  const current = fmt(state.game.seconds);
  const input = prompt('Set game clock (MM:SS):', current);
  if (!input) return;
  const m = input.match(/^(\d{1,2}):(\d{2})$/);
  if (!m) return alert('Please enter time as MM:SS');
  const mm = parseInt(m[1],10), ss = parseInt(m[2],10);
  if (ss>59) return alert('Seconds must be 00-59');
  state.game.seconds = Math.max(0, mm*60 + ss);
  renderAndPersist();
});

/**********************
 * Menu & View Switching
 **********************/
const menuToggleBtn = $('#menuToggle');
const menuDrawer = $('#menuDrawer');
const menuBackdrop = $('#menuBackdrop');

function openMenu(){
  document.body.classList.add('menu-open');
  if (menuDrawer) menuDrawer.setAttribute('aria-hidden', 'false');
  if (menuBackdrop) menuBackdrop.setAttribute('aria-hidden', 'false');
  if (menuToggleBtn) menuToggleBtn.setAttribute('aria-expanded', 'true');
  populateSyncForm();
}

function closeMenu(){
  document.body.classList.remove('menu-open');
  if (menuDrawer) menuDrawer.setAttribute('aria-hidden', 'true');
  if (menuBackdrop) menuBackdrop.setAttribute('aria-hidden', 'true');
  if (menuToggleBtn) menuToggleBtn.setAttribute('aria-expanded', 'false');
}

function toggleMenu(){
  if (document.body.classList.contains('menu-open')) closeMenu();
  else openMenu();
}

function setViewMode(mode){
  const next = mode === 'player' ? 'player' : 'ref';
  if (viewMode === next) return;
  viewMode = next;
  saveViewMode(viewMode);
  if (viewMode !== 'ref' && remoteSync.pushTimer){
    clearTimeout(remoteSync.pushTimer);
    remoteSync.pushTimer = null;
  }
  closeMenu();
  render();
}

if (menuToggleBtn) menuToggleBtn.addEventListener('click', toggleMenu);
if (menuBackdrop) menuBackdrop.addEventListener('click', closeMenu);
document.addEventListener('keydown', (ev)=>{ if (ev.key === 'Escape') closeMenu(); });

$$('#menuDrawer .drawer-item').forEach(btn => {
  btn.addEventListener('click', ()=>{ if (btn.dataset.view) setViewMode(btn.dataset.view); });
});

const syncForm = $('#syncForm');
if (syncForm){
  syncForm.addEventListener('submit', (ev)=>{
    ev.preventDefault();
    const url = syncForm.url.value.trim();
    const auth = syncForm.auth.value.trim();
    const game = syncForm.game.value.trim();
    if (!url || !game){
      alert('Enter both the database URL and a game code.');
      return;
    }
    remoteSync.config = { url, auth, game };
    saveRemoteConfig(remoteSync.config);
    updateRemoteStatus();
    connectRemote();
    closeMenu();
  });
}

const disconnectBtn = $('#syncDisconnect');
if (disconnectBtn){
  disconnectBtn.addEventListener('click', ()=>{
    disconnectRemote();
    remoteSync.config = null;
    clearRemoteConfig();
    remoteSync.status = 'idle';
    updateRemoteStatus();
    populateSyncForm();
  });
}

/**********************
 * Init
 **********************/
render();
updateRemoteStatus();
populateSyncForm();
if (remoteConfigured()) connectRemote();

/**********************
 * Self-tests (run with #test)
 **********************/
(function devTests(){
  if (location.hash !== '#test') return; console.group('[Self Tests]');
  try {
    const size = JSON.stringify(serializeState(state)).length; console.log('Persist size (bytes):', size); console.assert(size < 100000, 'payload <100KB');

    // Debounced writes
    let writes = 0; const _setItem = localStorage.setItem.bind(localStorage); localStorage.setItem = (k,v)=>{ if(k===STORAGE_KEY) writes++; _setItem(k,v); };
    for (let i=0;i<20;i++){ state.teams[0].score++; scheduleSave(); }
    setTimeout(()=>{ console.log('Debounced writes (<=5 expected):', writes); localStorage.setItem = _setItem; }, 1200);

    // Timeout -> Start behavior
    startTimeout(0);
    setTimeout(()=>{
      console.assert(state.game.timeoutSecondsRemaining>0, 'timeout should be running');
      toggleStartPause();
      console.assert(state.game.timeoutSecondsRemaining===0, 'timeout cleared on Start');
      console.assert(state.game.running===true, 'game clock should be running after Start');
      pauseClock();

      // Rush affects defense
      state.activeTeam = 0; const beforeDef = state.teams[1].rushes; document.getElementById('g_rushm1').click();
      console.assert(state.teams[1].rushes === Math.max(0, beforeDef-1), 'Rush decrements defending');

      // v9 Girl Play semantics
      state.activeTeam = 0; state.teams[0].girlPlay = 2; state.teams[0].downs = 1; // reset
      document.getElementById('g_guyPlay').click(); // expect 1
      console.assert(state.teams[0].girlPlay === 1, 'Guy Play decrements to 1');
      document.getElementById('g_guyPlay').click(); // expect 0
      console.assert(state.teams[0].girlPlay === 0, 'Guy Play decrements to 0 (Now)');
      document.getElementById('g_guyPlay').click(); // stays 0
      console.assert(state.teams[0].girlPlay === 0, 'Guy Play stays at 0');
      document.getElementById('g_girlPlay').click(); // reset to 2
      console.assert(state.teams[0].girlPlay === 2, 'Girl Play button resets to 2');

      // Halftime resets girl counter to 2
      startHalftime();
      console.assert(state.teams.every(t=> t.girlPlay===2), 'Halftime sets Girl Play In to 2');
      toggleStartPause(); console.assert(state.game.halftimeSecondsRemaining===0, 'halftime cleared on Start'); pauseClock();

      // Editable girl counter (note: direct call relies on implementation; this stays inside try/catch)
      const savedPrompt = window.prompt; window.prompt = ()=> '0';
      try { beginEditValue('girlPlay',0); } catch {}
      window.prompt = savedPrompt;

      console.groupEnd();
    }, 150);
  } catch (e) { console.warn('Self tests error:', e); console.groupEnd(); }
})();
</script>
</body>
</html>